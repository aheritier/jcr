Index: exo.jcr.component.webdav/src/test/java/org/exoplatform/services/jcr/webdav/ext/TestCaching.java
===================================================================
--- exo.jcr.component.webdav/src/test/java/org/exoplatform/services/jcr/webdav/ext/TestCaching.java	(revision 5842)
+++ exo.jcr.component.webdav/src/test/java/org/exoplatform/services/jcr/webdav/ext/TestCaching.java	(working copy)
@@ -76,6 +76,8 @@
       ContainerResponse response = service(WebDAVMethods.GET, getPathWS() + path, "", headers, null);
 
       assertEquals(HTTPStatus.OK, response.getStatus());
+
+      ((InputStream)response.getEntity()).close();
    }
 
    public void testIfModifiedSince() throws Exception
@@ -116,6 +118,8 @@
          String cacheControlHeader = response.getHttpHeaders().get(HttpHeaders.CACHE_CONTROL).toString();
          cacheControlHeader = cacheControlHeader.substring(1, cacheControlHeader.length() - 1);
          assertEquals(cacheControlHeader, cacheControlType.getCacheValue());
+
+         ((InputStream)response.getEntity()).close();
       }
    }
 
Index: exo.jcr.component.webdav/src/test/java/org/exoplatform/services/jcr/webdav/command/TestGet.java
===================================================================
--- exo.jcr.component.webdav/src/test/java/org/exoplatform/services/jcr/webdav/command/TestGet.java	(revision 5842)
+++ exo.jcr.component.webdav/src/test/java/org/exoplatform/services/jcr/webdav/command/TestGet.java	(working copy)
@@ -80,6 +80,8 @@
       }
       String str = sw.toString();
       assertEquals(fileContent, str);
+
+      content.close();
    }
 
    public void testNotFoundGet() throws Exception
Index: exo.jcr.component.webdav/src/main/java/org/exoplatform/services/jcr/webdav/command/GetCommand.java
===================================================================
--- exo.jcr.component.webdav/src/main/java/org/exoplatform/services/jcr/webdav/command/GetCommand.java	(revision 5842)
+++ exo.jcr.component.webdav/src/main/java/org/exoplatform/services/jcr/webdav/command/GetCommand.java	(working copy)
@@ -144,13 +144,16 @@
             // check before any other reads
             if (ifModifiedSince != null) 
             {
+               istream.close();
+
                DateFormat dateFormat = new SimpleDateFormat(WebDavConst.DateFormat.MODIFICATION, Locale.US);
                Date lastModifiedDate = dateFormat.parse(lastModifiedProperty.getValue());
                
                dateFormat = new SimpleDateFormat(WebDavConst.DateFormat.IF_MODIFIED_SINCE_PATTERN, Locale.US);
                Date ifModifiedSinceDate = dateFormat.parse(ifModifiedSince);
                
-               if(ifModifiedSinceDate.getTime() >= lastModifiedDate.getTime()){
+               if (ifModifiedSinceDate.getTime() >= lastModifiedDate.getTime())
+               {
                   return Response.notModified().entity("Not Modified").build();
                }
             }
@@ -181,9 +184,13 @@
             {
                Range range = ranges.get(0);
                if (!validateRange(range, contentLength))
-                  return Response.status(HTTPStatus.REQUESTED_RANGE_NOT_SATISFIABLE).header(
-                     ExtHttpHeaders.CONTENTRANGE, "bytes */" + contentLength).build();
+               {
+                  istream.close();
 
+                  return Response.status(HTTPStatus.REQUESTED_RANGE_NOT_SATISFIABLE)
+                     .header(ExtHttpHeaders.CONTENTRANGE, "bytes */" + contentLength).build();
+               }
+
                long start = range.getStart();
                long end = range.getEnd();
                long returnedContentLength = (end - start + 1);
Index: exo.jcr.docs/exo.jcr.docs.developer/en/src/main/docbook/en-US/modules/jcr/query-handler-config.xml
===================================================================
--- exo.jcr.docs/exo.jcr.docs.developer/en/src/main/docbook/en-US/modules/jcr/query-handler-config.xml	(revision 5842)
+++ exo.jcr.docs/exo.jcr.docs.developer/en/src/main/docbook/en-US/modules/jcr/query-handler-config.xml	(working copy)
@@ -177,14 +177,6 @@
       &lt;jgroupsConfig multiplexerStack="jcr.stack" /&gt;
       &lt;sync /&gt;
    &lt;/clustering&gt;
-   &lt;!-- Eviction configuration --&gt;
-   &lt;eviction wakeUpInterval="5000"&gt;
-      &lt;default algorithmClass="org.jboss.cache.eviction.FIFOAlgorithm" eventQueueSize="1000000"&gt;
-         &lt;property name="maxNodes" value="10000" /&gt;
-         &lt;property name="minTimeToLive" value="60000" /&gt;
-      &lt;/default&gt;
-   &lt;/eviction&gt;
-
 &lt;/jbosscache&gt;</programlisting></para>
 
       <para>See more about template configurations <link
Index: exo.jcr.docs/exo.jcr.docs.developer/en/src/main/docbook/en-US/modules/jcr/lock-manager-config.xml
===================================================================
--- exo.jcr.docs/exo.jcr.docs.developer/en/src/main/docbook/en-US/modules/jcr/lock-manager-config.xml	(revision 5842)
+++ exo.jcr.docs/exo.jcr.docs.developer/en/src/main/docbook/en-US/modules/jcr/lock-manager-config.xml	(working copy)
@@ -1,143 +1,160 @@
-<?xml version='1.0' encoding='UTF-8'?>
-<!-- This document was created with Syntext Serna Free. --><!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This document was created with Syntext Serna Free. -->
+<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
+"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
 <chapter id="JCR.LockManagerConfiguration">
-<?dbhtml filename="ch-lock-manager-config.html"?>  <title>LockManager configuration</title>
+  <?dbhtml filename="ch-lock-manager-config.html"?>
+
+  <title>LockManager configuration</title>
+
   <section>
     <title>Introduction</title>
+
     <para>What LockManager does?</para>
+
     <para>In general, LockManager stores Lock objects, so it can give a Lock
     object or can release it, etc.</para>
+
     <para>Also, LockManager is responsible for removing Locks that live too
-    long. This parameter may be configured with &quot;time-out&quot; property.</para>
-    <para>JCR provides two basic  implementations of LockManager:</para>
+    long. This parameter may be configured with "time-out" property.</para>
+
+    <para>JCR provides two basic implementations of LockManager:</para>
+
     <itemizedlist>
       <listitem>
         <para><classname>org.exoplatform.services.jcr.impl.core.lock.LockManagerImpl</classname>;</para>
       </listitem>
+
       <listitem>
         <para><classname>org.exoplatform.services.jcr.impl.core.lock.jbosscache.CacheableLockManagerImpl</classname>;</para>
       </listitem>
     </itemizedlist>
+
     <para>In this article, we will mostly mention about
     CacheableLockManagerImpl.</para>
+
     <para>You can enable LockManager by adding lock-manager-configuration to
     workspace-configuration.</para>
+
     <para>For example:</para>
-    <programlisting>&lt;workspace name=&quot;ws&quot;&gt;
+
+    <programlisting>&lt;workspace name="ws"&gt;
    ...
-   &lt;lock-manager class=&quot;org.exoplatform.services.jcr.impl.core.lock.jbosscache.CacheableLockManagerImpl&quot;&gt;
+   &lt;lock-manager class="org.exoplatform.services.jcr.impl.core.lock.jbosscache.CacheableLockManagerImpl"&gt;
       &lt;properties&gt;
-         &lt;property name=&quot;time-out&quot; value=&quot;15m&quot; /&gt;
+         &lt;property name="time-out" value="15m" /&gt;
          ...
       &lt;/properties&gt;
    &lt;/lock-manager&gt;               
    ...
 &lt;/workspace&gt;</programlisting>
   </section>
+
   <section>
     <title>LockManagerImpl</title>
+
     <para>LockManagerImpl is a simple implementation of LockManager, and also
     faster than CacheableLockManager. It stores Lock objects in HashMap and
     may also persist Locks if LockPersister is configured. LockManagerImpl
     does not support replication in any way.</para>
-    <para>See more about LockManager Configuration at <link linkend="JCR.eXoJCRconfiguration">here</link>.</para>
+
+    <para>See more about LockManager Configuration at <link
+    linkend="JCR.eXoJCRconfiguration">here</link>.</para>
   </section>
+
   <section>
     <title>CacheableLockManagerImpl</title>
-    <para>CacheableLockManagerImpl stores Lock objects in JBoss-cache, so Locks
-    are replicable and affect on cluster, not only a single node. Also,
+
+    <para>CacheableLockManagerImpl stores Lock objects in JBoss-cache, so
+    Locks are replicable and affect on cluster, not only a single node. Also,
     JBoss-cache has JDBCCacheLoader, so Locks will be stored to the
     database.</para>
-    <para>Both of the implementations support to remove Expired Locks. LockRemover separates threads, that periodically ask LockManager to remove Locks
-    that live so long. So, the timeout for LockRemover may be set
-    as follows, the default value is 30m.</para>
+
+    <para>Both of the implementations support to remove Expired Locks.
+    LockRemover separates threads, that periodically ask LockManager to remove
+    Locks that live so long. So, the timeout for LockRemover may be set as
+    follows, the default value is 30m.</para>
+
     <programlisting>&lt;properties&gt;
-   &lt;property name=&quot;time-out&quot; value=&quot;10m&quot; /&gt;
+   &lt;property name="time-out" value="10m" /&gt;
    ...
 &lt;/properties&gt;</programlisting>
+
     <section>
       <title>Configuration</title>
+
       <para>Replication requirements are the same for Cache.</para>
-      <para> You can see a full JCR configuration example at <link linkend="JCR.ClusterConfig.JCRExternalConfig">here</link>.</para>
+
+      <para>You can see a full JCR configuration example at <link
+      linkend="JCR.ClusterConfig.JCRExternalConfig">here</link>.</para>
+
       <para>Common tips:</para>
+
       <itemizedlist>
         <listitem>
-          <para><parameter>clusterName</parameter> (&quot;jbosscache-cluster-name&quot;)
+          <para><parameter>clusterName</parameter> ("jbosscache-cluster-name")
           must be unique;</para>
         </listitem>
+
         <listitem>
           <para><parameter>cache.jdbc.table.name</parameter> must be unique
           per datasource;</para>
         </listitem>
+
         <listitem>
           <para><parameter>cache.jdbc.fqn.type</parameter> and
-          cache.jdbc.node.type must be configured according to used
-          database;</para>
+          cache.jdbc.node.type must be configured according to your
+          database.</para>
         </listitem>
       </itemizedlist>
-      <para>There are a few ways to configure CacheableLockManagerImpl, and all
-      of them configure JBoss-cache and JDBCCacheLoader.</para>
-      <para>See <ulink url="http://community.jboss.org/wiki/JBossCacheJDBCCacheLoader">http://community.jboss.org/wiki/JBossCacheJDBCCacheLoader</ulink></para>
+
+      <para>There are a few ways to configure CacheableLockManagerImpl, and
+      all of them configure JBoss-cache and JDBCCacheLoader.</para>
+
+      <para>See <ulink
+      url="http://community.jboss.org/wiki/JBossCacheJDBCCacheLoader">http://community.jboss.org/wiki/JBossCacheJDBCCacheLoader</ulink></para>
     </section>
+
     <section>
       <title>Simple JbossCache Configuration</title>
-      <para>The first one is  putting JbossCache configuraion file path to
+
+      <para>The first one is putting JbossCache configuration file path to
       CacheableLockManagerImpl.</para>
+
       <para><note>
-          <para>This configuration is not so good as you  think. Because
-          the repository may contain many workspaces, and each workspace must
+          <para>This configuration is not so good as you think. Because the
+          repository may contain many workspaces, and each workspace must
           contain LockManager configuration, and LockManager configuration may
-          contain the JbossCache config file. So, the total configuration will grow
-          up. But it is useful if we want to have a single LockManager with a special
-          configuration.</para>
+          contain the JbossCache config file. So, the total configuration will
+          grow up. But it is useful if we want to have a single LockManager
+          with a special configuration.</para>
         </note></para>
+
       <para>Configuration is as follows:</para>
-      <programlisting>&lt;lock-manager class=&quot;org.exoplatform.services.jcr.impl.core.lock.jbosscache.CacheableLockManagerImpl&quot;&gt;
+
+      <programlisting>&lt;lock-manager class="org.exoplatform.services.jcr.impl.core.lock.jbosscache.CacheableLockManagerImpl"&gt;
    &lt;properties&gt;
-     &lt;property name=&quot;time-out&quot; value=&quot;15m&quot; /&gt;
-     &lt;property name=&quot;jbosscache-configuration&quot; value=&quot;conf/standalone/cluster/test-jbosscache-lock-config.xml&quot; /&gt;
+     &lt;property name="time-out" value="15m" /&gt;
+     &lt;property name="jbosscache-configuration" value="conf/standalone/cluster/test-jbosscache-lock-config.xml" /&gt;
    &lt;/properties&gt;
 &lt;/lock-manager&gt;</programlisting>
-      <para><filename>test-jbosscache-lock-config.xml</filename><programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
-&lt;jbosscache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;urn:jboss:jbosscache-core:config:3.2&quot;&gt;
 
- &lt;locking useLockStriping=&quot;false&quot; concurrencyLevel=&quot;50000&quot; lockParentForChildInsertRemove=&quot;false&quot; lockAcquisitionTimeout=&quot;20000&quot; /&gt;
+      <para><filename>test-jbosscache-lock-config.xml</filename><programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
+&lt;jbosscache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:jboss:jbosscache-core:config:3.2"&gt;
 
- &lt;clustering mode=&quot;replication&quot; clusterName=&quot;JBoss-Cache-Lock-Cluster_Name&quot;&gt;
-  &lt;stateRetrieval timeout=&quot;20000&quot; fetchInMemoryState=&quot;false&quot; nonBlocking=&quot;true&quot; /&gt;
-  &lt;jgroupsConfig&gt;
+ &lt;locking useLockStriping="false" concurrencyLevel="50000" lockParentForChildInsertRemove="false" lockAcquisitionTimeout="20000" /&gt;
 
-   &lt;TCP bind_addr=&quot;127.0.0.1&quot; start_port=&quot;9800&quot; loopback=&quot;true&quot; recv_buf_size=&quot;20000000&quot; send_buf_size=&quot;640000&quot; discard_incompatible_packets=&quot;true&quot;
-    max_bundle_size=&quot;64000&quot; max_bundle_timeout=&quot;30&quot; use_incoming_packet_handler=&quot;true&quot; enable_bundling=&quot;false&quot; use_send_queues=&quot;false&quot; sock_conn_timeout=&quot;300&quot;
-    skip_suspected_members=&quot;true&quot; use_concurrent_stack=&quot;true&quot; thread_pool.enabled=&quot;true&quot; thread_pool.min_threads=&quot;1&quot; thread_pool.max_threads=&quot;25&quot;
-    thread_pool.keep_alive_time=&quot;5000&quot; thread_pool.queue_enabled=&quot;false&quot; thread_pool.queue_max_size=&quot;100&quot; thread_pool.rejection_policy=&quot;run&quot;
-    oob_thread_pool.enabled=&quot;true&quot; oob_thread_pool.min_threads=&quot;1&quot; oob_thread_pool.max_threads=&quot;8&quot; oob_thread_pool.keep_alive_time=&quot;5000&quot;
-    oob_thread_pool.queue_enabled=&quot;false&quot; oob_thread_pool.queue_max_size=&quot;100&quot; oob_thread_pool.rejection_policy=&quot;run&quot; /&gt;
-   &lt;MPING timeout=&quot;2000&quot; num_initial_members=&quot;2&quot; mcast_port=&quot;34540&quot; bind_addr=&quot;127.0.0.1&quot; mcast_addr=&quot;224.0.0.1&quot; /&gt;
-
-
-   &lt;MERGE2 max_interval=&quot;30000&quot; min_interval=&quot;10000&quot; /&gt;
-   &lt;FD_SOCK /&gt;
-   &lt;FD max_tries=&quot;5&quot; shun=&quot;true&quot; timeout=&quot;10000&quot; /&gt;
-   &lt;VERIFY_SUSPECT timeout=&quot;1500&quot; /&gt;
-   &lt;pbcast.NAKACK discard_delivered_msgs=&quot;true&quot; gc_lag=&quot;0&quot; retransmit_timeout=&quot;300,600,1200,2400,4800&quot; use_mcast_xmit=&quot;false&quot; /&gt;
-   &lt;UNICAST timeout=&quot;300,600,1200,2400,3600&quot; /&gt;
-   &lt;pbcast.STABLE desired_avg_gossip=&quot;50000&quot; max_bytes=&quot;400000&quot; stability_delay=&quot;1000&quot; /&gt;
-   &lt;pbcast.GMS join_timeout=&quot;5000&quot; print_local_addr=&quot;true&quot; shun=&quot;false&quot; view_ack_collection_timeout=&quot;5000&quot; view_bundling=&quot;true&quot; /&gt;
-   &lt;FRAG2 frag_size=&quot;60000&quot; /&gt;
-   &lt;pbcast.STREAMING_STATE_TRANSFER /&gt;
-  &lt;pbcast.FLUSH timeout=&quot;0&quot; /&gt;
-
-  &lt;/jgroupsConfig
-
-  &lt;sync /&gt;
+ &lt;clustering mode="replication" clusterName="JBoss-Cache-Lock-Cluster_Name"&gt;
+   &lt;stateRetrieval timeout="20000" fetchInMemoryState="false" /&gt;
+   &lt;jgroupsConfig multiplexerStack="jcr.stack" /&gt;
+   &lt;sync /&gt;
  &lt;/clustering&gt;
 
- &lt;loaders passivation=&quot;false&quot; shared=&quot;true&quot;&gt;
+ &lt;loaders passivation="false" shared="true"&gt;
   &lt;preload&gt;
-   &lt;node fqn=&quot;/&quot; /&gt;
+   &lt;node fqn="/" /&gt;
   &lt;/preload&gt;
-  &lt;loader class=&quot;org.jboss.cache.loader.JDBCCacheLoader&quot; async=&quot;false&quot; fetchPersistentState=&quot;false&quot; ignoreModifications=&quot;false&quot; purgeOnStartup=&quot;false&quot;&gt;
+  &lt;loader class="org.exoplatform.services.jcr.impl.core.lock.jbosscache.JDBCCacheLoader" async="false" fetchPersistentState="false" ignoreModifications="false" purgeOnStartup="false"&gt;
    &lt;properties&gt;
     cache.jdbc.table.name=jcrlocks_ws
     cache.jdbc.table.create=true
@@ -155,53 +172,69 @@
  &lt;/loaders&gt;
 
 &lt;/jbosscache&gt;</programlisting></para>
+
       <para>Configuration requirements:</para>
+
       <itemizedlist>
         <listitem>
-          <para>&lt;clustering mode=&quot;replication&quot;
-          clusterName=&quot;JBoss-Cache-Lock-Cluster_Name&quot;&gt; - the cluster name must
-          be unique;</para>
+          <para>&lt;clustering mode="replication"
+          clusterName="JBoss-Cache-Lock-Cluster_Name"&gt; - the cluster name
+          must be unique;</para>
         </listitem>
+
         <listitem>
           <para><parameter>cache.jdbc.table.name</parameter> must be unique
           per datasource;</para>
         </listitem>
+
         <listitem>
           <para><parameter>cache.jdbc.node.type</parameter> and
           <parameter>cache.jdbc.fqn.type</parameter> must be configured
-          according to using the database. See <link endterm="datatypes.title" linkend="datatypes"/> .</para>
+          according to your database.</para>
+
+          <note>
+            <para>To prevent any consistency issue regarding the lock data
+            please ensure that your cache loader is
+            <emphasis>org.exoplatform.services.jcr.impl.core.lock.jbosscache.JDBCCacheLoader</emphasis>
+            and that your database engine is transactional.</para>
+          </note>
         </listitem>
       </itemizedlist>
     </section>
+
     <section>
       <title>Template JBossCache Configuration</title>
-      <para>The second one is using the template JBoss-cache configuration for all
-      LockManagers.</para>
+
+      <para>The second one is using the template JBoss-cache configuration for
+      all LockManagers.</para>
+
       <para><citetitle>Lock template configuration</citetitle></para>
+
       <para><filename>test-jbosscache-lock.xml</filename></para>
-      <programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
-&lt;jbosscache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;urn:jboss:jbosscache-core:config:3.1&quot;&gt;
 
-   &lt;locking useLockStriping=&quot;false&quot; concurrencyLevel=&quot;50000&quot; lockParentForChildInsertRemove=&quot;false&quot;
-      lockAcquisitionTimeout=&quot;20000&quot; /&gt;
+      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
+&lt;jbosscache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:jboss:jbosscache-core:config:3.1"&gt;
 
-   &lt;clustering mode=&quot;replication&quot; clusterName=&quot;${jbosscache-cluster-name}&quot;&gt;
-      &lt;stateRetrieval timeout=&quot;20000&quot; fetchInMemoryState=&quot;false&quot; /&gt;
-      &lt;jgroupsConfig multiplexerStack=&quot;jcr.stack&quot; /&gt;
+   &lt;locking useLockStriping="false" concurrencyLevel="500" lockParentForChildInsertRemove="false"
+      lockAcquisitionTimeout="20000" /&gt;
+
+   &lt;clustering mode="replication" clusterName="${jbosscache-cluster-name}"&gt;
+      &lt;stateRetrieval timeout="20000" fetchInMemoryState="false" /&gt;
+      &lt;jgroupsConfig multiplexerStack="jcr.stack" /&gt;
       &lt;sync /&gt;
    &lt;/clustering&gt;
 
-   &lt;loaders passivation=&quot;false&quot; shared=&quot;true&quot;&gt;
+   &lt;loaders passivation="false" shared="true"&gt;
       &lt;!-- All the data of the JCR locks needs to be loaded at startup --&gt;
       &lt;preload&gt;
-         &lt;node fqn=&quot;/&quot; /&gt;
+         &lt;node fqn="/" /&gt;
       &lt;/preload&gt;  
       &lt;!--
       For another cache-loader class you should use another template with
       cache-loader specific parameters
       -&gt;
-      &lt;loader class=&quot;org.jboss.cache.loader.JDBCCacheLoader&quot; async=q&quot;false&quot; fetchPersistentState=&quot;false&quot;
-         ignoreModifications=&quot;false&quot; purgeOnStartup=&quot;false&quot;&gt;
+      &lt;loader class="org.exoplatform.services.jcr.impl.core.lock.jbosscache.JDBCCacheLoader" async="false" fetchPersistentState="false"
+         ignoreModifications="false" purgeOnStartup="false"&gt;
          &lt;properties&gt;
             cache.jdbc.table.name=${jbosscache-cl-cache.jdbc.table.name}
             cache.jdbc.table.create=${jbosscache-cl-cache.jdbc.table.create}
@@ -217,70 +250,76 @@
       &lt;/loader&gt;
    &lt;/loaders&gt;
 &lt;/jbosscache&gt;</programlisting>
+
       <para>As you see, all configurable parameters are filled by templates
       and will be replaced by LockManagers configuration parameters:</para>
-      <programlisting>&lt;lock-manager class=&quot;org.exoplatform.services.jcr.impl.core.lock.jbosscache.CacheableLockManagerImpl&quot;&gt;
+
+      <programlisting>&lt;lock-manager class="org.exoplatform.services.jcr.impl.core.lock.jbosscache.CacheableLockManagerImpl"&gt;
    &lt;properties&gt;
-      &lt;property name=&quot;time-out&quot; value=&quot;15m&quot; /&gt;
-      &lt;property name=&quot;jbosscache-configuration&quot; value=&quot;test-jbosscache-lock.xml&quot; /&gt;
-      &lt;property name=&quot;jgroups-configuration&quot; value=&quot;udp-mux.xml&quot; /&gt;
-      &lt;property name=&quot;jgroups-multiplexer-stack&quot; value=&quot;true&quot; /&gt;
-      &lt;property name=&quot;jbosscache-cluster-name&quot; value=&quot;JCR-cluster-locks-ws&quot; /&gt;
-      &lt;property name=&quot;jbosscache-cl-cache.jdbc.table.name&quot; value=&quot;jcrlocks_ws&quot; /&gt;
-      &lt;property name=&quot;jbosscache-cl-cache.jdbc.table.create&quot; value=&quot;true&quot; /&gt;
-      &lt;property name=&quot;jbosscache-cl-cache.jdbc.table.drop&quot; value=&quot;false&quot; /&gt;
-      &lt;property name=&quot;jbosscache-cl-cache.jdbc.table.primarykey&quot; value=&quot;jcrlocks_ws_pk&quot; /&gt;
-      &lt;property name=&quot;jbosscache-cl-cache.jdbc.fqn.column&quot; value=&quot;fqn&quot; /&gt;
-      &lt;property name=&quot;jbosscache-cl-cache.jdbc.fqn.type&quot; value=&quot;AUTO&quot;/&gt;
-      &lt;property name=&quot;jbosscache-cl-cache.jdbc.node.column&quot; value=&quot;node&quot; /&gt;
-      &lt;property name=&quot;jbosscache-cl-cache.jdbc.node.type&quot; value=&quot;AUTO&quot;/&gt;
-      &lt;property name=&quot;jbosscache-cl-cache.jdbc.parent.column&quot; value=&quot;parent&quot; /&gt;
-      &lt;property name=&quot;jbosscache-cl-cache.jdbc.datasource&quot; value=&quot;jdbcjcr&quot; /&gt;
+      &lt;property name="time-out" value="15m" /&gt;
+      &lt;property name="jbosscache-configuration" value="test-jbosscache-lock.xml" /&gt;
+      &lt;property name="jgroups-configuration" value="udp-mux.xml" /&gt;
+      &lt;property name="jgroups-multiplexer-stack" value="true" /&gt;
+      &lt;property name="jbosscache-cluster-name" value="JCR-cluster-locks-ws" /&gt;
+      &lt;property name="jbosscache-cl-cache.jdbc.table.name" value="jcrlocks_ws" /&gt;
+      &lt;property name="jbosscache-cl-cache.jdbc.table.create" value="true" /&gt;
+      &lt;property name="jbosscache-cl-cache.jdbc.table.drop" value="false" /&gt;
+      &lt;property name="jbosscache-cl-cache.jdbc.table.primarykey" value="jcrlocks_ws_pk" /&gt;
+      &lt;property name="jbosscache-cl-cache.jdbc.fqn.column" value="fqn" /&gt;
+      &lt;property name="jbosscache-cl-cache.jdbc.fqn.type" value="AUTO"/&gt;
+      &lt;property name="jbosscache-cl-cache.jdbc.node.column" value="node" /&gt;
+      &lt;property name="jbosscache-cl-cache.jdbc.node.type" value="AUTO"/&gt;
+      &lt;property name="jbosscache-cl-cache.jdbc.parent.column" value="parent" /&gt;
+      &lt;property name="jbosscache-cl-cache.jdbc.datasource" value="jdbcjcr" /&gt;
    &lt;/properties&gt;
 &lt;/lock-manager&gt;</programlisting>
+
       <para>Configuration requirements:<itemizedlist>
           <listitem>
             <para><parameter>jbosscache-cl-cache.jdbc.fqn.column</parameter>
             and <parameter>jbosscache-cl-cache.jdbc.node.type</parameter> is
-            the same  as cache.jdbc.fqn.type and cache.jdbc.node.type in
+            the same as cache.jdbc.fqn.type and cache.jdbc.node.type in
             JBoss-Cache configuration. You can set those data types according
-            to database type (See <link endterm="datatypes.title" linkend="datatypes"/>) or set it as AUTO (or do not set at
-            all) and data type will be detected automatically.</para>
+            to your database type or set it as AUTO (or do not set at all) and
+            data type will be detected automatically.</para>
           </listitem>
+
           <listitem>
-            <para>As you see, jgroups-configuration is moved to separate the configuration
-            file - udp-mux.xml. In this case, the udp-mux.xml file is a common JGroup
-            configuration  for all components (QueryHandler, Cache, LockManager), but
-            we can still create our own configuration.</para>
+            <para>As you see, jgroups-configuration is moved to separate the
+            configuration file - udp-mux.xml. In this case, the udp-mux.xml
+            file is a common JGroup configuration for all components
+            (QueryHandler, Cache, LockManager), but we can still create our
+            own configuration.</para>
           </listitem>
         </itemizedlist></para>
-      <para><filename>our-udp-mux.xml</filename><programlisting>&lt;protocol_stacks&gt;
-   &lt;stack name=&quot;jcr.stack&quot;&gt;
+
+      <para><filename>our udp-mux.xml</filename><programlisting>&lt;protocol_stacks&gt;
+   &lt;stack name="jcr.stack"&gt;
       &lt;config&gt;
-         &lt;UDP mcast_addr=&quot;228.10.10.10&quot; mcast_port=&quot;45588&quot; tos=&quot;8&quot; ucast_recv_buf_size=&quot;20000000&quot;
-            ucast_send_buf_size=&quot;640000&quot; mcast_recv_buf_size=&quot;25000000&quot; mcast_send_buf_size=&quot;640000&quot; loopback=&quot;false&quot;
-            discard_incompatible_packets=&quot;true&quot; max_bundle_size=&quot;64000&quot; max_bundle_timeout=&quot;30&quot;
-            use_incoming_packet_handler=&quot;true&quot; ip_ttl=&quot;2&quot; enable_bundling=&quot;true&quot; enable_diagnostics=&quot;true&quot;
-            thread_naming_pattern=&quot;cl&quot; use_concurrent_stack=&quot;true&quot; thread_pool.enabled=&quot;true&quot; thread_pool.min_threads=&quot;2&quot;
-            thread_pool.max_threads=&quot;8&quot; thread_pool.keep_alive_time=&quot;5000&quot; thread_pool.queue_enabled=&quot;true&quot;
-            thread_pool.queue_max_size=&quot;1000&quot; thread_pool.rejection_policy=&quot;discard&quot; oob_thread_pool.enabled=&quot;true&quot;
-            oob_thread_pool.min_threads=&quot;1&quot; oob_thread_pool.max_threads=&quot;8&quot; oob_thread_pool.keep_alive_time=&quot;5000&quot;
-            oob_thread_pool.queue_enabled=&quot;false&quot; oob_thread_pool.queue_max_size=&quot;100&quot; oob_thread_pool.rejection_policy=&quot;Run&quot; /&gt;
+         &lt;UDP mcast_addr="228.10.10.10" mcast_port="45588" tos="8" ucast_recv_buf_size="20000000"
+            ucast_send_buf_size="640000" mcast_recv_buf_size="25000000" mcast_send_buf_size="640000" loopback="false"
+            discard_incompatible_packets="true" max_bundle_size="64000" max_bundle_timeout="30"
+            use_incoming_packet_handler="true" ip_ttl="2" enable_bundling="true" enable_diagnostics="true"
+            thread_naming_pattern="cl" use_concurrent_stack="true" thread_pool.enabled="true" thread_pool.min_threads="2"
+            thread_pool.max_threads="8" thread_pool.keep_alive_time="5000" thread_pool.queue_enabled="true"
+            thread_pool.queue_max_size="1000" thread_pool.rejection_policy="discard" oob_thread_pool.enabled="true"
+            oob_thread_pool.min_threads="1" oob_thread_pool.max_threads="8" oob_thread_pool.keep_alive_time="5000"
+            oob_thread_pool.queue_enabled="false" oob_thread_pool.queue_max_size="100" oob_thread_pool.rejection_policy="Run" /&gt;
 
-         &lt;PING timeout=&quot;2000&quot; num_initial_members=&quot;3&quot; /&gt;
-         &lt;MERGE2 max_interval=&quot;30000&quot; min_interval=&quot;10000&quot; /&gt;
+         &lt;PING timeout="2000" num_initial_members="3" /&gt;
+         &lt;MERGE2 max_interval="30000" min_interval="10000" /&gt;
          &lt;FD_SOCK /&gt;
-         &lt;FD timeout=&quot;10000&quot; max_tries=&quot;5&quot; shun=&quot;true&quot; /&gt;
-         &lt;VERIFY_SUSPECT timeout=&quot;1500&quot; /&gt;
+         &lt;FD timeout="10000" max_tries="5" shun="true" /&gt;
+         &lt;VERIFY_SUSPECT timeout="1500" /&gt;
          &lt;BARRIER /&gt;
-         &lt;pbcast.NAKACK use_stats_for_retransmission=&quot;false&quot; exponential_backoff=&quot;150&quot; use_mcast_xmit=&quot;true&quot;
-            gc_lag=&quot;0&quot; retransmit_timeout=&quot;50,300,600,1200&quot; discard_delivered_msgs=&quot;true&quot; /&gt;
-         &lt;UNICAST timeout=&quot;300,600,1200&quot; /&gt;
-         &lt;pbcast.STABLE stability_delay=&quot;1000&quot; desired_avg_gossip=&quot;50000&quot; max_bytes=&quot;1000000&quot; /&gt;
-         &lt;VIEW_SYNC avg_send_interval=&quot;60000&quot; /&gt;
-         &lt;pbcast.GMS print_local_addr=&quot;true&quot; join_timeout=&quot;3000&quot; shun=&quot;false&quot; view_bundling=&quot;true&quot; /&gt;
-         &lt;FC max_credits=&quot;500000&quot; min_threshold=&quot;0.20&quot; /&gt;
-         &lt;FRAG2 frag_size=&quot;60000&quot; /&gt;
+         &lt;pbcast.NAKACK use_stats_for_retransmission="false" exponential_backoff="150" use_mcast_xmit="true"
+            gc_lag="0" retransmit_timeout="50,300,600,1200" discard_delivered_msgs="true" /&gt;
+         &lt;UNICAST timeout="300,600,1200" /&gt;
+         &lt;pbcast.STABLE stability_delay="1000" desired_avg_gossip="50000" max_bytes="1000000" /&gt;
+         &lt;VIEW_SYNC avg_send_interval="60000" /&gt;
+         &lt;pbcast.GMS print_local_addr="true" join_timeout="3000" shun="false" view_bundling="true" /&gt;
+         &lt;FC max_credits="500000" min_threshold="0.20" /&gt;
+         &lt;FRAG2 frag_size="60000" /&gt;
          &lt;!--pbcast.STREAMING_STATE_TRANSFER /--&gt;
          &lt;pbcast.STATE_TRANSFER /&gt;
          &lt;!-- pbcast.FLUSH  /--&gt;
@@ -288,62 +327,94 @@
    &lt;/stack&gt;
 &lt;/protocol_stacks&gt; </programlisting></para>
     </section>
+
     <section id="datatypes">
       <title id="datatypes.title">Data Types in Different Databases</title>
+
       <table>
         <title>FQN type and node type in different databases</title>
+
         <tgroup cols="3">
           <thead>
             <row>
               <entry>DataBase name</entry>
+
               <entry>Node data type</entry>
+
               <entry>FQN data type</entry>
             </row>
           </thead>
+
           <tbody>
             <row>
               <entry>default</entry>
+
               <entry>BLOB</entry>
+
               <entry>VARCHAR(512)</entry>
             </row>
+
             <row>
               <entry>HSSQL</entry>
+
               <entry>OBJECT</entry>
+
               <entry>VARCHAR(512)</entry>
             </row>
+
             <row>
               <entry>MySQL</entry>
+
               <entry>LONGBLOB</entry>
+
               <entry>VARCHAR(512)</entry>
             </row>
+
             <row>
               <entry>ORACLE</entry>
+
               <entry>BLOB</entry>
+
               <entry>VARCHAR2(512)</entry>
             </row>
+
             <row>
               <entry>PostgreSQL</entry>
+
               <entry>bytea</entry>
+
               <entry>VARCHAR(512)</entry>
             </row>
+
             <row>
               <entry>MSSQL</entry>
+
               <entry>VARBINARY(MAX)</entry>
+
               <entry>VARCHAR(512)</entry>
             </row>
+
             <row>
               <entry>DB2</entry>
+
               <entry>BLOB</entry>
+
               <entry>VARCHAR(512)</entry>
             </row>
+
             <row>
               <entry>Sybase</entry>
+
               <entry>IMAGE</entry>
+
               <entry>VARCHAR(512)</entry>
             </row>
+
             <row>
               <entry>Ingres</entry>
+
               <entry>long byte</entry>
+
               <entry>VARCHAR(512)</entry>
             </row>
           </tbody>
Index: exo.jcr.docs/exo.jcr.docs.developer/en/src/main/docbook/en-US/modules/jcr/jbosscache-configuration-templates.xml
===================================================================
--- exo.jcr.docs/exo.jcr.docs.developer/en/src/main/docbook/en-US/modules/jcr/jbosscache-configuration-templates.xml	(revision 5842)
+++ exo.jcr.docs/exo.jcr.docs.developer/en/src/main/docbook/en-US/modules/jcr/jbosscache-configuration-templates.xml	(working copy)
@@ -84,7 +84,7 @@
       <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;jbosscache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:jboss:jbosscache-core:config:3.1"&gt;
 
-   &lt;locking useLockStriping="false" concurrencyLevel="50000" lockParentForChildInsertRemove="false"
+   &lt;locking useLockStriping="false" concurrencyLevel="500" lockParentForChildInsertRemove="false"
       lockAcquisitionTimeout="20000" /&gt;
 
    &lt;clustering mode="replication" clusterName="${jbosscache-cluster-name}"&gt;
@@ -95,11 +95,11 @@
 
    &lt;!-- Eviction configuration --&gt;
    &lt;eviction wakeUpInterval="5000"&gt;
-      &lt;default algorithmClass="org.jboss.cache.eviction.LRUAlgorithm"
+      &lt;default algorithmClass="org.jboss.cache.eviction.ExpirationAlgorithm"
          actionPolicyClass="org.exoplatform.services.jcr.impl.dataflow.persistent.jbosscache.ParentNodeEvictionActionPolicy"
          eventQueueSize="1000000"&gt;
          &lt;property name="maxNodes" value="1000000" /&gt;
-         &lt;property name="timeToLive" value="120000" /&gt;
+         &lt;property name="warnNoExpirationKey" value="false" /&gt;
       &lt;/default&gt;
    &lt;/eviction&gt;
 &lt;/jbosscache&gt;</programlisting>
@@ -133,7 +133,7 @@
       <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;jbosscache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:jboss:jbosscache-core:config:3.1"&gt;
 
-   &lt;locking useLockStriping="false" concurrencyLevel="50000" lockParentForChildInsertRemove="false"
+   &lt;locking useLockStriping="false" concurrencyLevel="500" lockParentForChildInsertRemove="false"
       lockAcquisitionTimeout="20000" /&gt;
    &lt;clustering mode="replication" clusterName="${jbosscache-cluster-name}"&gt;
       &lt;stateRetrieval timeout="20000" fetchInMemoryState="false" /&gt;
@@ -144,7 +144,7 @@
       &lt;preload&gt;
          &lt;node fqn="/" /&gt;
       &lt;/preload&gt;
-      &lt;loader class="org.jboss.cache.loader.JDBCCacheLoader" async="false" fetchPersistentState="false"
+      &lt;loader class="org.exoplatform.services.jcr.impl.core.lock.jbosscache.JDBCCacheLoader" async="false" fetchPersistentState="false"
          ignoreModifications="false" purgeOnStartup="false"&gt;
          &lt;properties&gt;
             cache.jdbc.table.name=${jbosscache-cl-cache.jdbc.table.name}
@@ -162,6 +162,13 @@
    &lt;/loaders&gt;
 &lt;/jbosscache&gt;</programlisting>
 
+      <para><note>
+          <para>To prevent any consistency issue regarding the lock data
+          please ensure that your cache loader is
+          <emphasis>org.exoplatform.services.jcr.impl.core.lock.jbosscache.JDBCCacheLoader</emphasis>
+          and that your database engine is transactional.</para>
+        </note></para>
+
       <table>
         <title>Template variables</title>
 
@@ -228,20 +235,13 @@
 
       <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;jbosscache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:jboss:jbosscache-core:config:3.1"&gt;
-   &lt;locking useLockStriping="false" concurrencyLevel="50000" lockParentForChildInsertRemove="false"
+   &lt;locking useLockStriping="false" concurrencyLevel="500" lockParentForChildInsertRemove="false"
       lockAcquisitionTimeout="20000" /&gt;
    &lt;clustering mode="replication" clusterName="${jbosscache-cluster-name}"&gt;
       &lt;stateRetrieval timeout="20000" fetchInMemoryState="false" /&gt;
       &lt;jgroupsConfig multiplexerStack="jcr.stack" /&gt;
       &lt;sync /&gt;
    &lt;/clustering&gt;
-   &lt;!-- Eviction configuration --&gt;
-   &lt;eviction wakeUpInterval="5000"&gt;
-      &lt;default algorithmClass="org.jboss.cache.eviction.FIFOAlgorithm" eventQueueSize="1000000"&gt;
-         &lt;property name="maxNodes" value="10000" /&gt;
-         &lt;property name="minTimeToLive" value="60000" /&gt;
-      &lt;/default&gt;
-   &lt;/eviction&gt;
 &lt;/jbosscache&gt;</programlisting>
 
       <table>
Index: exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/dataflow/persistent/jbosscache/TestJBossCacheWorkspaceStorageCacheInClusterMode.java
===================================================================
--- exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/dataflow/persistent/jbosscache/TestJBossCacheWorkspaceStorageCacheInClusterMode.java	(revision 5842)
+++ exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/dataflow/persistent/jbosscache/TestJBossCacheWorkspaceStorageCacheInClusterMode.java	(working copy)
@@ -759,6 +759,10 @@
       public void rollback() throws IllegalStateException, RepositoryException
       {
       }
+      
+      public void prepare() throws IllegalStateException, RepositoryException
+      {
+      }
 
       public void update(NodeData data) throws RepositoryException, UnsupportedOperationException,
          InvalidItemStateException, IllegalStateException
Index: exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/dataflow/persistent/TestCacheableWorkspaceDataManager.java
===================================================================
--- exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/dataflow/persistent/TestCacheableWorkspaceDataManager.java	(revision 5842)
+++ exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/dataflow/persistent/TestCacheableWorkspaceDataManager.java	(working copy)
@@ -412,6 +412,10 @@
       public void commit() throws IllegalStateException, RepositoryException
       {
       }
+      
+      public void prepare() throws IllegalStateException, RepositoryException
+      {
+      }
 
       public void delete(NodeData data) throws RepositoryException, UnsupportedOperationException,
          InvalidItemStateException, IllegalStateException
@@ -526,7 +530,6 @@
       {
       }
 
-      @Override
       public int getLastOrderNumber(NodeData parent) throws RepositoryException
       {
          return -1;
Index: exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/storage/fs/TestRandomValueIO.java
===================================================================
--- exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/storage/fs/TestRandomValueIO.java	(revision 5842)
+++ exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/storage/fs/TestRandomValueIO.java	(working copy)
@@ -18,16 +18,13 @@
  */
 package org.exoplatform.services.jcr.impl.storage.fs;
 
-import org.exoplatform.services.jcr.JcrImplBaseTest;
-import org.exoplatform.services.jcr.core.value.EditableBinaryValue;
-import org.exoplatform.services.jcr.core.value.ReadableBinaryValue;
-
 import java.io.BufferedInputStream;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.util.Calendar;
 import java.util.Random;
 
@@ -35,6 +32,10 @@
 import javax.jcr.Property;
 import javax.jcr.Session;
 
+import org.exoplatform.services.jcr.JcrImplBaseTest;
+import org.exoplatform.services.jcr.core.value.EditableBinaryValue;
+import org.exoplatform.services.jcr.core.value.ReadableBinaryValue;
+
 /**
  * Created by The eXo Platform SAS
  * 
@@ -476,7 +477,9 @@
       testRoot.save();
 
       byte[] buff = new byte[npos];
-      testRoot.getProperty(pname).getStream().read(buff);
+      InputStream stream = testRoot.getProperty(pname).getStream();
+      stream.read(buff);
+      stream.close();
 
       assertEquals("Value content is wrong ", content.substring(0, npos), new String(buff));
 
Index: exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/storage/value/fs/TestFileIOChannel.java
===================================================================
--- exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/storage/value/fs/TestFileIOChannel.java	(revision 5842)
+++ exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/storage/value/fs/TestFileIOChannel.java	(working copy)
@@ -18,6 +18,13 @@
  */
 package org.exoplatform.services.jcr.impl.storage.value.fs;
 
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
 import junit.framework.TestCase;
 
 import org.exoplatform.services.jcr.datamodel.ValueData;
@@ -25,12 +32,6 @@
 import org.exoplatform.services.jcr.impl.storage.value.ValueDataResourceHolder;
 import org.exoplatform.services.jcr.impl.util.io.FileCleaner;
 
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.util.ArrayList;
-import java.util.List;
-
 /**
  * Created by The eXo Platform SAS.
  * 
@@ -110,14 +111,20 @@
       assertEquals(0, v0.getOrderNumber());
       assertEquals(10, v0.getAsByteArray().length);
       assertTrue(v0.isByteArray());
-      assertNotNull(v0.getAsStream());
 
+      InputStream in = v0.getAsStream();
+      assertNotNull(in);
+      in.close();
+
       ValueData v1 = channel.read("testReadFromIOChannel", 1, 11);
       assertEquals(20, v1.getLength());
       assertEquals(1, v1.getOrderNumber());
       assertFalse(v1.isByteArray());
-      assertNotNull(v1.getAsStream());
 
+      in = v1.getAsStream();
+      assertNotNull(in);
+      in.close();
+
       try
       {
          v1.getAsByteArray();
Index: exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/storage/value/fs/Probe.java
===================================================================
--- exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/storage/value/fs/Probe.java	(revision 5842)
+++ exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/impl/storage/value/fs/Probe.java	(working copy)
@@ -20,6 +20,7 @@
 
 import java.io.File;
 import java.io.FileInputStream;
+import java.io.IOException;
 
 /**
  * Created by The eXo Platform SAS.
@@ -47,21 +48,32 @@
 
    public void run()
    {
-      System.out.println("Thread started " + this.getName());
+      FileInputStream is = null;
       try
       {
-         FileInputStream is = new FileInputStream(file);
+         is = new FileInputStream(file);
          while (is.read() > 0)
          {
             len++;
          }
-
       }
       catch (Exception e)
       {
          e.printStackTrace();
       }
-      System.out.println("Thread finished " + this.getName() + " read: " + len);
+      finally
+      {
+         if (is != null)
+         {
+            try
+            {
+               is.close();
+            }
+            catch (IOException e)
+            {
+            }
+         }
+      }
    }
 
    public int getLen()
Index: exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/BaseStandaloneTest.java
===================================================================
--- exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/BaseStandaloneTest.java	(revision 5842)
+++ exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/BaseStandaloneTest.java	(working copy)
@@ -298,65 +298,88 @@
    protected void compareStream(InputStream etalon, InputStream data, long etalonPos, long dataPos, long length)
       throws IOException, CompareStreamException
    {
-      int dindex = 0;
+      try
+      {
+         int dindex = 0;
 
-      skipStream(etalon, etalonPos);
-      skipStream(data, dataPos);
+         skipStream(etalon, etalonPos);
+         skipStream(data, dataPos);
 
-      byte[] ebuff = new byte[1024];
-      int eread = 0;
+         byte[] ebuff = new byte[1024];
+         int eread = 0;
 
-      while ((eread = etalon.read(ebuff)) > 0)
-      {
-         byte[] dbuff = new byte[eread];
-         int erindex = 0;
-         while (erindex < eread)
+         while ((eread = etalon.read(ebuff)) > 0)
          {
-            int dread = -1;
-            try
+            byte[] dbuff = new byte[eread];
+            int erindex = 0;
+            while (erindex < eread)
             {
-               dread = data.read(dbuff);
-            }
-            catch (IOException e)
-            {
-               throw new CompareStreamException("Streams is not equals by length or data stream is unreadable. Cause: "
-                  + e.getMessage());
-            }
+               int dread = -1;
+               try
+               {
+                  dread = data.read(dbuff);
+               }
+               catch (IOException e)
+               {
+                  throw new CompareStreamException(
+                     "Streams is not equals by length or data stream is unreadable. Cause: " + e.getMessage());
+               }
 
-            if (dread == -1)
-            {
-               throw new CompareStreamException(
-                  "Streams is not equals by length. Data end-of-stream reached at position " + dindex);
-            }
-
-            for (int i = 0; i < dread; i++)
-            {
-               byte eb = ebuff[i];
-               byte db = dbuff[i];
-               if (eb != db)
+               if (dread == -1)
                {
-                  throw new CompareStreamException("Streams is not equals. Wrong byte stored at position " + dindex
-                     + " of data stream. Expected 0x" + Integer.toHexString(eb) + " '" + new String(new byte[]{eb})
-                     + "' but found 0x" + Integer.toHexString(db) + " '" + new String(new byte[]{db}) + "'");
+                  throw new CompareStreamException(
+                     "Streams is not equals by length. Data end-of-stream reached at position " + dindex);
                }
 
-               erindex++;
-               dindex++;
-               if (length > 0 && dindex >= length)
+               for (int i = 0; i < dread; i++)
                {
-                  return; // tested length reached
+                  byte eb = ebuff[i];
+                  byte db = dbuff[i];
+                  if (eb != db)
+                  {
+                     throw new CompareStreamException("Streams is not equals. Wrong byte stored at position " + dindex
+                        + " of data stream. Expected 0x" + Integer.toHexString(eb) + " '" + new String(new byte[]{eb})
+                        + "' but found 0x" + Integer.toHexString(db) + " '" + new String(new byte[]{db}) + "'");
+                  }
+
+                  erindex++;
+                  dindex++;
+                  if (length > 0 && dindex >= length)
+                  {
+                     return; // tested length reached
+                  }
                }
+
+               if (dread < eread)
+                  dbuff = new byte[eread - dread];
             }
+         }
 
-            if (dread < eread)
-               dbuff = new byte[eread - dread];
+         if (data.available() > 0)
+         {
+            throw new CompareStreamException(
+               "Streams is not equals by length. Data stream contains more data. Were read " + dindex);
          }
       }
+      finally
+      {
+         try
+         {
+            data.close();
+         }
+         catch (IOException e)
+         {
+            log.error(e.getMessage(), e);
+         }
 
-      if (data.available() > 0)
-      {
-         throw new CompareStreamException("Streams is not equals by length. Data stream contains more data. Were read "
-            + dindex);
+         try
+         {
+            etalon.close();
+         }
+         catch (IOException e)
+         {
+            log.error(e.getMessage(), e);
+         }
       }
    }
 
Index: exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/api/i18n/TestI18nValues.java
===================================================================
--- exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/api/i18n/TestI18nValues.java	(revision 5842)
+++ exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/api/i18n/TestI18nValues.java	(working copy)
@@ -201,6 +201,7 @@
             int rec = is.read(buf);
             baos.write(buf, 0, rec);
          }
+         is.close();
          byte[] valueBytes = baos.toByteArray();
          String content = new String(valueBytes, "UTF-8");
          assertTrue("Content must be identical. '" + source + "' = '" + content + "'", equalsBinary(valueBytes, source
@@ -264,6 +265,7 @@
             int rec = is.read(buf);
             baos.write(buf, 0, rec);
          }
+         is.close();
          byte[] valueBytes = baos.toByteArray();
          String content = new String(valueBytes, "UTF-8");
          assertTrue("Content must be identical. '" + source + "' = '" + content + "'", equalsBinary(valueBytes, source
Index: exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/usecases/version/FileRestoreTest.java
===================================================================
--- exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/usecases/version/FileRestoreTest.java	(revision 5842)
+++ exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/usecases/version/FileRestoreTest.java	(working copy)
@@ -18,16 +18,17 @@
  */
 package org.exoplatform.services.jcr.usecases.version;
 
-import org.exoplatform.services.jcr.usecases.BaseUsecasesTest;
-
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
+import java.io.InputStream;
 import java.util.Calendar;
 
 import javax.jcr.Node;
 import javax.jcr.version.Version;
 
+import org.exoplatform.services.jcr.usecases.BaseUsecasesTest;
+
 /**
  * Created by The eXo Platform SAS.
  * 
@@ -88,18 +89,18 @@
       file.getNode("jcr:content").setProperty("jcr:data", new FileInputStream(tempFile2));
       session.save();
 
-      log
-         .info("ADD VERSION #2 : file size = " + contentNode.getProperty("jcr:data").getStream().available() + " bytes");
-      compareStream(new FileInputStream(tempFile2), contentNode.getProperty("jcr:data").getStream());
+      InputStream in = contentNode.getProperty("jcr:data").getStream();
+      log.info("ADD VERSION #2 : file size = " + in.available() + " bytes");
+      compareStream(new FileInputStream(tempFile2), in);
 
       file.checkin(); // v2
       file.checkout();
       file.getNode("jcr:content").setProperty("jcr:data", new FileInputStream(tempFile3));
       session.save();
 
-      log
-         .info("ADD VERSION #3 : file size = " + contentNode.getProperty("jcr:data").getStream().available() + " bytes");
-      compareStream(new FileInputStream(tempFile3), contentNode.getProperty("jcr:data").getStream());
+      in = contentNode.getProperty("jcr:data").getStream();
+      log.info("ADD VERSION #3 : file size = " + in.available() + " bytes");
+      compareStream(new FileInputStream(tempFile3), in);
 
       // restore version v2
       Version v2 = file.getBaseVersion();
Index: exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/usecases/common/TestExportImportAmongSessions.java
===================================================================
--- exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/usecases/common/TestExportImportAmongSessions.java	(revision 5842)
+++ exo.jcr.component.core/src/test/java/org/exoplatform/services/jcr/usecases/common/TestExportImportAmongSessions.java	(working copy)
@@ -82,6 +82,7 @@
          InputStream storedData = ntFile.getProperty("jcr:content/jcr:data").getStream();
          assertTrue("AFTER EXPORT/IMPORT. Binary content must be same", checkBinaryEquals(new ByteArrayInputStream(
             TEST_BINARY_CONTENT), storedData));
+         storedData.close();
       }
       catch (RepositoryException e)
       {
@@ -112,6 +113,7 @@
       Node ntFile = testNode.getNode(TEST_NTFILE);
       InputStream storedData = ntFile.getProperty("jcr:content/jcr:data").getStream();
       assertTrue("BEFORE EXPORT/IMPORT. Binary content must be same", checkBinaryEquals(etalonData, storedData));
+      storedData.close();
 
       File outputFile = File.createTempFile("jcr_bin_test", ".tmp");
       outputFile.deleteOnExit();
@@ -130,6 +132,7 @@
          storedData = ntFile.getProperty("jcr:content/jcr:data").getStream();
          assertTrue("AFTER EXPORT/IMPORT. Binary content must be same", checkBinaryEquals(new ByteArrayInputStream(
             TEST_BINARY_CONTENT), storedData));
+         storedData.close();
       }
       catch (RepositoryException e)
       {
@@ -145,6 +148,7 @@
          storedData = ntFile.getProperty("jcr:content/jcr:data").getStream();
          assertTrue("AFTER EXPORT/IMPORT AFTER SAVE. Binary content must be same", checkBinaryEquals(
             new ByteArrayInputStream(TEST_BINARY_CONTENT), storedData));
+         storedData.close();
       }
       catch (RepositoryException e)
       {
Index: exo.jcr.component.core/src/test/resources/conf/standalone/cluster/test-jbosscache-lock.xml
===================================================================
--- exo.jcr.component.core/src/test/resources/conf/standalone/cluster/test-jbosscache-lock.xml	(revision 5842)
+++ exo.jcr.component.core/src/test/resources/conf/standalone/cluster/test-jbosscache-lock.xml	(working copy)
@@ -19,7 +19,7 @@
 			For another cache-loader class you should use another template with
 			cache-loader specific parameters
 		-->
-      <loader class="org.jboss.cache.loader.JDBCCacheLoader" async="false" fetchPersistentState="false"
+      <loader class="org.exoplatform.services.jcr.impl.core.lock.jbosscache.JDBCCacheLoader" async="false" fetchPersistentState="false"
          ignoreModifications="false" purgeOnStartup="false">
          <properties>
             cache.jdbc.table.name=${jbosscache-cl-cache.jdbc.table.name}
Index: exo.jcr.component.core/src/test/resources/conf/standalone/test-jbosscache-lock.xml
===================================================================
--- exo.jcr.component.core/src/test/resources/conf/standalone/test-jbosscache-lock.xml	(revision 5842)
+++ exo.jcr.component.core/src/test/resources/conf/standalone/test-jbosscache-lock.xml	(working copy)
@@ -13,7 +13,7 @@
 			For another cache-loader class you should use another template with
 			cache-loader specific parameters
 		-->
-      <loader class="org.jboss.cache.loader.JDBCCacheLoader" async="false" fetchPersistentState="false"
+      <loader class="org.exoplatform.services.jcr.impl.core.lock.jbosscache.JDBCCacheLoader" async="false" fetchPersistentState="false"
          ignoreModifications="false" purgeOnStartup="false">
          <properties>
             cache.jdbc.table.name=${jbosscache-cl-cache.jdbc.table.name}
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/core/lock/jbosscache/JDBCConnectionFactory.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/core/lock/jbosscache/JDBCConnectionFactory.java	(revision 0)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/core/lock/jbosscache/JDBCConnectionFactory.java	(revision 0)
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2012 eXo Platform SAS.
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * This software is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this software; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
+ */
+package org.exoplatform.services.jcr.impl.core.lock.jbosscache;
+
+import org.exoplatform.services.log.ExoLogger;
+import org.exoplatform.services.log.Log;
+import org.jboss.cache.loader.AdjListJDBCCacheLoaderConfig;
+import org.jboss.cache.loader.ConnectionFactory;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+
+import javax.naming.InitialContext;
+import javax.naming.NamingException;
+import javax.sql.DataSource;
+
+/**
+ * @author <a href="mailto:nicolas.filotto@exoplatform.com">Nicolas Filotto</a>
+ * @version $Id$
+ */
+public class JDBCConnectionFactory implements ConnectionFactory
+{
+
+   /**
+    * Logger
+    */
+   private static final Log LOG = ExoLogger.getLogger("exo.jcr.component.core.NonManagedConnectionFactory");
+   private static final boolean trace = LOG.isTraceEnabled();
+
+   static final ThreadLocal<Connection> connection = new ThreadLocal<Connection>();
+
+   private DataSource dataSource;
+   private String datasourceName;
+
+   public void setConfig(AdjListJDBCCacheLoaderConfig config)
+   {
+      datasourceName = config.getDatasourceName();
+   }
+
+   public void start() throws Exception
+   {
+      // A datasource will be registered in JNDI in the start portion of
+      // its lifecycle, so now that we are in start() we can look it up
+      InitialContext ctx = null;
+      try
+      {
+         ctx = new InitialContext();
+         dataSource = (DataSource) ctx.lookup(datasourceName);
+         if (trace)
+         {
+            LOG.trace("Datasource lookup for " + datasourceName + " succeded: " + dataSource);
+         }
+      }
+      catch (NamingException e)
+      {
+         reportAndRethrowError("Failed to lookup datasource " + datasourceName, e);
+      }
+      finally
+      {
+         if (ctx != null)
+         {
+            try
+            {
+               ctx.close();
+            }
+            catch (NamingException e)
+            {
+               LOG.warn("Failed to close naming context.", e);
+            }
+         }
+      }
+   }
+
+   public void prepare(Object tx)
+   {
+      Connection con = getConnection();
+      try
+      {
+         if (con.getAutoCommit())
+         {
+            con.setAutoCommit(false);
+         }
+      }
+      catch (Exception e)
+      {
+         reportAndRethrowError("Failed to set auto-commit", e);
+      }
+
+      /* Connection set in ThreadLocal, no reason to return. It was previously returned for legacy purpouses
+      and to trace log the connection opening in JDBCCacheLoader. */
+      connection.set(con);
+
+      if (trace)
+      {
+         LOG.trace("opened tx connection: tx=" + tx + ", con=" + con);
+      }
+
+   }
+
+   public Connection getConnection()
+   {
+      Connection con = connection.get();
+
+      if (con == null)
+      {
+         try
+         {
+            con = checkoutConnection();
+            //               connection.set(con);
+         }
+         catch (SQLException e)
+         {
+            reportAndRethrowError("Failed to get connection for datasource=" + datasourceName, e);
+         }
+      }
+
+      if (trace)
+      {
+         LOG.trace("using connection: " + con);
+      }
+
+      return con;
+   }
+
+   public Connection checkoutConnection() throws SQLException
+   {
+      return dataSource.getConnection();
+   }
+
+   public void commit(Object tx)
+   {
+      Connection con = connection.get();
+      if (con == null)
+      {
+         throw new IllegalStateException("Failed to commit: thread is not associated with the connection!");
+      }
+
+      try
+      {
+         con.commit();
+         if (trace)
+         {
+            LOG.trace("committed tx=" + tx + ", con=" + con);
+         }
+      }
+      catch (SQLException e)
+      {
+         reportAndRethrowError("Failed to commit", e);
+      }
+      finally
+      {
+         closeTxConnection(con);
+      }
+   }
+
+   public void rollback(Object tx)
+   {
+      Connection con = connection.get();
+
+      try
+      {
+         con.rollback();
+         if (trace)
+         {
+            LOG.trace("rolledback tx=" + tx + ", con=" + con);
+         }
+      }
+      catch (SQLException e)
+      {
+         reportAndRethrowError("Failed to rollback", e);
+      }
+      finally
+      {
+         closeTxConnection(con);
+      }
+   }
+
+   public void close(Connection con)
+   {
+      if (con != null && con != connection.get())
+      {
+         try
+         {
+            con.close();
+
+            if (trace)
+            {
+               LOG.trace("closed non tx connection: " + con);
+            }
+         }
+         catch (SQLException e)
+         {
+            LOG.warn("Failed to close connection " + con, e);
+         }
+      }
+   }
+
+   public void stop()
+   {
+   }
+
+   private void closeTxConnection(Connection con)
+   {
+      safeClose(con);
+      connection.set(null);
+   }
+
+   private void safeClose(Connection con)
+   {
+      if (con != null)
+      {
+         try
+         {
+            con.close();
+         }
+         catch (SQLException e)
+         {
+            LOG.warn("Failed to close connection", e);
+         }
+      }
+   }
+
+   private void reportAndRethrowError(String message, Exception cause) throws IllegalStateException
+   {
+      LOG.error(message, cause);
+      throw new IllegalStateException(message, cause);
+   }
+}
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/core/lock/jbosscache/JDBCCacheLoader.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/core/lock/jbosscache/JDBCCacheLoader.java	(revision 0)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/core/lock/jbosscache/JDBCCacheLoader.java	(revision 0)
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2012 eXo Platform SAS.
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * This software is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this software; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
+ */
+package org.exoplatform.services.jcr.impl.core.lock.jbosscache;
+
+import org.jboss.cache.config.CacheLoaderConfig;
+import org.jboss.cache.config.CacheLoaderConfig.IndividualCacheLoaderConfig;
+import org.jboss.cache.loader.AdjListJDBCCacheLoaderConfig;
+
+/**
+ * This class is used to override the method AdjListJDBCCacheLoader#setConfig in order
+ * to be able to use a data source name even in case of non managed data sources.
+ * 
+ * @author <a href="mailto:nicolas.filotto@exoplatform.com">Nicolas Filotto</a>
+ * @version $Id$
+ */
+public class JDBCCacheLoader extends org.jboss.cache.loader.JDBCCacheLoader
+{
+
+   @Override
+   public void setConfig(IndividualCacheLoaderConfig base)
+   {
+      super.setConfig(base);
+      AdjListJDBCCacheLoaderConfig config = processConfig(base);
+
+      if (config.getDatasourceName() == null)
+      {
+         return;
+      }
+      /* We create the JDBCConnectionFactory instance but the JNDI lookup is no done until
+the start method is called, since that's when its registered in its lifecycle */
+      cf = new JDBCConnectionFactory();
+      /* We set the configuration */
+      cf.setConfig(config);
+   }
+
+   /**
+    * {@inheritDoc}
+    */
+   @Override
+   protected AdjListJDBCCacheLoaderConfig processConfig(CacheLoaderConfig.IndividualCacheLoaderConfig base)
+   {
+      AdjListJDBCCacheLoaderConfig config = super.processConfig(base);
+      config.setClassName(getClass().getName());
+      return config;
+   }
+}
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/core/value/BinaryValue.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/core/value/BinaryValue.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/core/value/BinaryValue.java	(working copy)
@@ -196,9 +196,7 @@
          // edited BLOB file, make a copy
          try
          {
-            EditableValueData copy =
-               new EditableValueData(oldValue.getAsStream(), oldValue.getOrderNumber(), null, -1, null);
-            return copy;
+            return new EditableValueData(oldValue.getAsStream(), oldValue.getOrderNumber(), null, -1, null);
          }
          catch (FileNotFoundException e)
          {
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/core/value/BaseValue.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/core/value/BaseValue.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/core/value/BaseValue.java	(working copy)
@@ -252,14 +252,7 @@
     */
    public long getLength()
    {
-      try
-      {
-         return getLocalData(type == PropertyType.BINARY).getLength();
-      }
-      catch (IOException e)
-      {
-         throw new RuntimeException(e);
-      }
+      return getInternalData().getLength();
    }
 
    /**
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/xml/exporting/SystemViewContentExporter.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/xml/exporting/SystemViewContentExporter.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/xml/exporting/SystemViewContentExporter.java	(working copy)
@@ -191,13 +191,20 @@
             else
             {
                InputStream is = data.getAsStream();
-               byte[] buffer = new byte[3 * 1024 * 3];
-               int len;
-               while ((len = is.read(buffer)) > 0)
+               try
                {
-                  char[] charbuf1 = Base64.encode(buffer, 0, len, 0, "").toCharArray();
-                  contentHandler.characters(charbuf1, 0, charbuf1.length);
+                  byte[] buffer = new byte[3 * 1024 * 3];
+                  int len;
+                  while ((len = is.read(buffer)) > 0)
+                  {
+                     char[] charbuf1 = Base64.encode(buffer, 0, len, 0, "").toCharArray();
+                     contentHandler.characters(charbuf1, 0, charbuf1.length);
+                  }
                }
+               finally
+               {
+                  is.close();
+               }
             }
          }
       }
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/xml/exporting/SystemViewStreamExporter.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/xml/exporting/SystemViewStreamExporter.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/xml/exporting/SystemViewStreamExporter.java	(working copy)
@@ -190,13 +190,20 @@
             else
             {
                InputStream is = data.getAsStream();
-               byte[] buffer = new byte[BUFFER_SIZE];
-               int len;
-               while ((len = is.read(buffer)) > 0)
+               try
                {
-                  char[] charbuf1 = Base64.encode(buffer, 0, len, 0, "").toCharArray();
-                  writer.writeCharacters(charbuf1, 0, charbuf1.length);
+                  byte[] buffer = new byte[BUFFER_SIZE];
+                  int len;
+                  while ((len = is.read(buffer)) > 0)
+                  {
+                     char[] charbuf1 = Base64.encode(buffer, 0, len, 0, "").toCharArray();
+                     writer.writeCharacters(charbuf1, 0, charbuf1.length);
+                  }
                }
+               finally
+               {
+                  is.close();
+               }
             }
          }
       }
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/EditableValueData.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/EditableValueData.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/EditableValueData.java	(working copy)
@@ -129,12 +129,10 @@
          {
             byte[] tmpBuff = new byte[2048];
             int read = 0;
-            int len = 0;
 
             while ((read = stream.read(tmpBuff)) >= 0)
             {
                sfout.write(tmpBuff, 0, read);
-               len += read;
             }
          }
          catch (final IOException e)
@@ -156,6 +154,10 @@
                }
             };
          }
+         finally
+         {
+            stream.close();
+         }
 
          this.data = null;
 
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/WorkspacePersistentDataManager.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/WorkspacePersistentDataManager.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/WorkspacePersistentDataManager.java	(working copy)
@@ -58,6 +58,9 @@
 
 import javax.jcr.InvalidItemStateException;
 import javax.jcr.RepositoryException;
+import javax.transaction.Status;
+import javax.transaction.Synchronization;
+import javax.transaction.TransactionManager;
 
 /**
  * Created by The eXo Platform SAS.<br>
@@ -86,10 +89,6 @@
    protected final WorkspaceDataContainer systemDataContainer;
 
    /**
-    * Value sorages provider (for dest file suggestion on save).
-    */
-   // TODO protected final ValueStoragePluginProvider valueStorageProvider;
-   /**
     * Persistent level listeners. This listeners can be filtered by filters from
     * <code>liestenerFilters</code> list.
     */
@@ -109,6 +108,11 @@
     * Read-only status.
     */
    protected boolean readOnly = false;
+   
+   /**
+    * The transaction manager
+    */
+   protected final TransactionManager transactionManager;
 
    /**
     * WorkspacePersistentDataManager constructor.
@@ -119,9 +123,24 @@
     *          holder of system workspace data container
     */
    public WorkspacePersistentDataManager(WorkspaceDataContainer dataContainer,
-   //ValueStoragePluginProvider valueStorageProvider, 
       SystemDataContainerHolder systemDataContainerHolder)
    {
+      this(dataContainer, systemDataContainerHolder, null);
+   }
+
+   /**
+    * WorkspacePersistentDataManager constructor.
+    * 
+    * @param dataContainer
+    *          workspace data container
+    * @param systemDataContainerHolder
+    *          holder of system workspace data container
+    * @param tm
+    *          the transaction manager
+    */
+   public WorkspacePersistentDataManager(WorkspaceDataContainer dataContainer,
+      SystemDataContainerHolder systemDataContainerHolder, TransactionManager transactionManager)
+   {
       this.dataContainer = dataContainer;
       this.systemDataContainer = systemDataContainerHolder.getContainer();
       // this.valueStorageProvider = valueStorageProvider;
@@ -129,6 +148,7 @@
       this.listeners = new ArrayList<ItemsPersistenceListener>();
       this.mandatoryListeners = new ArrayList<MandatoryItemsPersistenceListener>();
       this.liestenerFilters = new ArrayList<ItemsPersistenceListenerFilter>();
+      this.transactionManager = transactionManager;
    }
 
    /**
@@ -146,7 +166,7 @@
 
       // whole log will be reconstructed with persisted data 
       ItemStateChangesLog persistedLog;
-
+      boolean failed = true;
       try
       {
          if (changesLog instanceof PlainChangesLogImpl)
@@ -172,7 +192,10 @@
             // we don't support other types now... i.e. add else-if for that type here
             throw new RepositoryException("Unsupported changes log class " + changesLog.getClass());
          }
-         persister.commit();
+         persister.prepare();
+         notifySaveItems(persistedLog, true);
+         onCommit(persister);
+         failed = false;
       }
       catch (IOException e)
       {
@@ -180,12 +203,73 @@
       }
       finally
       {
-         persister.rollback();
+         persister.clear();
+         if (failed)
+         {
+            persister.rollback();
+         }
       }
 
-      notifySaveItems(persistedLog, true);
    }
+   
+   private void onCommit(final ChangesLogPersister persister) throws RepositoryException
+   {
+      if (transactionManager == null)
+      {
+         persister.commit();
+      }
+      else
+      {
+         try
+         {
+            transactionManager.getTransaction().registerSynchronization(new Synchronization()
+            {
 
+               public void beforeCompletion()
+               {
+               }
+
+               public void afterCompletion(int status)
+               {
+                  switch (status)
+                  {
+                     case Status.STATUS_COMMITTED:
+                        try
+                        {
+                           persister.commit();
+                        }
+                        catch (Exception e)
+                        {
+                           throw new RuntimeException("Could not commit the transaction", e);
+                        }
+                        break;
+                     case Status.STATUS_UNKNOWN:
+                        LOG.warn("Status UNKNOWN received in afterCompletion method, some data could have been corrupted !!");
+                     case Status.STATUS_MARKED_ROLLBACK:
+                     case Status.STATUS_ROLLEDBACK:
+                        try
+                        {
+                           persister.rollback();
+                        }
+                        catch (Exception e)
+                        {
+                           LOG.error("Could not roll back the transaction", e);
+                        }
+                        break;
+
+                     default:
+                        throw new IllegalStateException("illegal status: " + status);
+                  }                  
+               }
+            });
+         }
+         catch (Exception e)
+         {
+            throw new RepositoryException("Cannot register the synchronization for a late commit", e);
+         }
+      }
+   }
+   
    class ChangesLogPersister
    {
 
@@ -207,20 +291,35 @@
          }
       }
 
-      protected void rollback() throws IllegalStateException, RepositoryException
+      protected void prepare() throws IllegalStateException, RepositoryException
       {
          if (thisConnection != null && thisConnection.isOpened())
          {
-            thisConnection.rollback();
+            thisConnection.prepare();
          }
          if (systemConnection != null && !systemConnection.equals(thisConnection) && systemConnection.isOpened())
          {
-            systemConnection.rollback();
+            systemConnection.prepare();
          }
+      }
 
+      protected void clear()
+      {
          // help to GC
          addedNodes.clear();
       }
+      
+      protected void rollback() throws IllegalStateException, RepositoryException
+      {
+         if (thisConnection != null && thisConnection.isOpened())
+         {
+            thisConnection.rollback();
+         }
+         if (systemConnection != null && !systemConnection.equals(thisConnection) && systemConnection.isOpened())
+         {
+            systemConnection.rollback();
+         }
+      }
 
       protected WorkspaceStorageConnection getSystemConnection() throws RepositoryException
       {
@@ -475,7 +574,6 @@
    /**
     * {@inheritDoc}
     */
-   @Override
    public int getLastOrderNumber(final NodeData nodeData) throws RepositoryException
    {
       final WorkspaceStorageConnection con = dataContainer.openConnection();
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/FilePersistedValueData.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/FilePersistedValueData.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/FilePersistedValueData.java	(working copy)
@@ -57,8 +57,6 @@
 
    protected File file;
 
-   protected FileChannel channel;
-
    /**
     *   Empty constructor to serialization.
     */
@@ -112,37 +110,46 @@
     */
    public long read(OutputStream stream, long length, long position) throws IOException
    {
-      if (channel == null)
-      {
-         channel = new FileInputStream(file).getChannel();
-      }
+      FileInputStream in = new FileInputStream(file);
 
-      // validation
-      if (position >= channel.size() && position > 0)
+      try
       {
-         throw new IOException("Position " + position + " out of value size " + channel.size());
-      }
+         FileChannel channel = in.getChannel();
 
-      if (position + length >= channel.size())
-      {
-         length = channel.size() - position;
-      }
+         // validation
+         if (position >= channel.size() && position > 0)
+         {
+            throw new IOException("Position " + position + " out of value size " + channel.size());
+         }
 
-      MappedByteBuffer bb = channel.map(FileChannel.MapMode.READ_ONLY, position, length);
+         if (position + length >= channel.size())
+         {
+            length = channel.size() - position;
+         }
 
-      WritableByteChannel ch;
-      if (stream instanceof FileOutputStream)
-      {
-         ch = ((FileOutputStream)stream).getChannel();
+         WritableByteChannel ch;
+         if (stream instanceof FileOutputStream)
+         {
+            ch = ((FileOutputStream)stream).getChannel();
+         }
+         else
+         {
+            ch = Channels.newChannel(stream);
+         }
+
+         long size = 0;
+         do
+         {
+            size += channel.transferTo(position, length, ch);
+         }
+         while (size != length);
+
+         return size;
       }
-      else
+      finally
       {
-         ch = Channels.newChannel(stream);
+         in.close();
       }
-      ch.write(bb);
-      ch.close();
-
-      return length;
    }
 
    /**
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/CacheableWorkspaceDataManager.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/CacheableWorkspaceDataManager.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/CacheableWorkspaceDataManager.java	(working copy)
@@ -43,7 +43,6 @@
 import java.util.concurrent.CountDownLatch;
 
 import javax.jcr.RepositoryException;
-import javax.transaction.TransactionManager;
 
 /**
  * Created by The eXo Platform SAS. 
@@ -67,8 +66,6 @@
     */
    protected final ConcurrentMap<Integer, DataRequest> requestCache;
 
-   private TransactionManager transactionManager;
-
    /**
     * ItemData request, used on get operations.
     * 
@@ -297,13 +294,11 @@
    public CacheableWorkspaceDataManager(WorkspaceDataContainer dataContainer, WorkspaceStorageCache cache,
       SystemDataContainerHolder systemDataContainerHolder, TransactionService transactionService)
    {
-      super(dataContainer, systemDataContainerHolder);
+      super(dataContainer, systemDataContainerHolder, transactionService.getTransactionManager());
       this.cache = cache;
 
       this.requestCache = new ConcurrentHashMap<Integer, DataRequest>();
       addItemPersistenceListener(cache);
-
-      transactionManager = transactionService.getTransactionManager();
    }
 
    /**
@@ -319,20 +314,13 @@
    public CacheableWorkspaceDataManager(WorkspaceDataContainer dataContainer, WorkspaceStorageCache cache,
       SystemDataContainerHolder systemDataContainerHolder)
    {
-      super(dataContainer, systemDataContainerHolder);
+      super(dataContainer, systemDataContainerHolder, cache instanceof JBossCacheWorkspaceStorageCache
+         ? ((JBossCacheWorkspaceStorageCache)cache).getTransactionManager() : null);
       this.cache = cache;
 
       this.requestCache = new ConcurrentHashMap<Integer, DataRequest>();
       addItemPersistenceListener(cache);
 
-      if (cache instanceof JBossCacheWorkspaceStorageCache)
-      {
-         transactionManager = ((JBossCacheWorkspaceStorageCache)cache).getTransactionManager();
-      }
-      else
-      {
-         transactionManager = null;
-      }
    }
 
    /**
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/inmemory/InmemoryStorageConnection.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/inmemory/InmemoryStorageConnection.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/inmemory/InmemoryStorageConnection.java	(working copy)
@@ -235,6 +235,10 @@
    public void rollback() throws IllegalStateException, RepositoryException
    {
    }
+   
+   public void prepare() throws IllegalStateException, RepositoryException
+   {
+   }
 
    public void close() throws IllegalStateException, RepositoryException
    {
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/jdbc/JDBCStorageConnection.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/jdbc/JDBCStorageConnection.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/jdbc/JDBCStorageConnection.java	(working copy)
@@ -336,18 +336,40 @@
       {
          closeStatements();
 
-         if (!this.readOnly)
+         if (!readOnly)
          {
-            dbConnection.rollback();
+            try
+            {
+               dbConnection.rollback();               
+            }
+            finally
+            {
+               // rollback from the end
+               IOException e = null;
+               for (int p = valueChanges.size() - 1; p >= 0; p--)
+               {
+                  try
+                  {
+                     valueChanges.get(p).rollback();
+                  }
+                  catch (IOException e1)
+                  {
+                     if (e == null)
+                     {
+                        e = e1;
+                     }
+                     else
+                     {
+                        LOG.error("Could not rollback value change", e1);
+                     }
+                  }
+               }               
+               if (e != null)
+               {
+                  throw e;
+               }
+            }
          }
-
-         dbConnection.close();
-
-         // rollback from the end
-         for (int p = valueChanges.size() - 1; p >= 0; p--)
-         {
-            valueChanges.get(p).rollback();
-         }
       }
       catch (SQLException e)
       {
@@ -360,6 +382,17 @@
       finally
       {
          valueChanges.clear();
+         try
+         {
+            dbConnection.close();
+         }
+         catch (SQLException e)
+         {
+            if (LOG.isWarnEnabled())
+            {
+               LOG.warn("Could not close the connection", e);
+            }
+         }         
       }
    }
 
@@ -561,6 +594,24 @@
          LOG.error("Can't close the statement: " + e);
       }
    }
+   
+   /**
+    * {@inheritDoc}
+    */
+   public final void prepare() throws IllegalStateException, RepositoryException
+   {
+      try
+      {
+         for (ValueIOChannel vo : valueChanges)
+         {
+            vo.prepare();
+         }
+      }
+      catch (IOException e)
+      {
+         throw new RepositoryException(e);
+      }
+   }
 
    /**
     * {@inheritDoc}
@@ -572,33 +623,44 @@
       {
          closeStatements();
 
-         if (!this.readOnly)
+         if (!readOnly)
          {
-            dbConnection.commit();
-         }
-
-         dbConnection.close();
-
-         try
-         {
-            for (ValueIOChannel vo : valueChanges)
+            try
             {
-               vo.commit();
+               for (ValueIOChannel vo : valueChanges)
+               {
+                  vo.twoPhaseCommit();
+               }
             }
+            catch (IOException e)
+            {
+               throw new RepositoryException(e);
+            }
+            finally
+            {
+               valueChanges.clear();
+            }
+            dbConnection.commit();
          }
-         catch (IOException e)
-         {
-            throw new RepositoryException(e);
-         }
-         finally
-         {
-            valueChanges.clear();
-         }
       }
       catch (SQLException e)
       {
          throw new RepositoryException(e);
       }
+      finally
+      {
+         try
+         {
+            dbConnection.close();
+         }
+         catch (SQLException e)
+         {
+            if (LOG.isWarnEnabled())
+            {
+               LOG.warn("Could not close the connection", e);
+            }
+         }         
+      }
    }
 
    /**
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/jdbc/statistics/StatisticsJDBCStorageConnection.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/jdbc/statistics/StatisticsJDBCStorageConnection.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/jdbc/statistics/StatisticsJDBCStorageConnection.java	(working copy)
@@ -63,6 +63,12 @@
     * <code>rollback()</code>
     */
    private static final String ROLLBACK_DESCR = "rollback";
+   
+   /**
+    * The description of the statistics corresponding to the method 
+    * <code>prepare()</code>
+    */
+   private static final String PREPARE_DESCR = "prepare";   
 
    /**
     * The description of the statistics corresponding to the method 
@@ -200,6 +206,8 @@
       ALL_STATISTICS.put(RENAME_NODE_DATA_DESCR, new Statistics(GLOBAL_STATISTICS, RENAME_NODE_DATA_DESCR));
       // Rollback
       ALL_STATISTICS.put(ROLLBACK_DESCR, new Statistics(GLOBAL_STATISTICS, ROLLBACK_DESCR));
+      // Prepare
+      ALL_STATISTICS.put(PREPARE_DESCR, new Statistics(GLOBAL_STATISTICS, PREPARE_DESCR));
       // Others
       ALL_STATISTICS.put(IS_OPENED_DESCR, new Statistics(null, IS_OPENED_DESCR));
       ALL_STATISTICS.put(CLOSE_DESCR, new Statistics(null, CLOSE_DESCR));
@@ -524,6 +532,23 @@
    /**
     * {@inheritDoc}
     */
+   public void prepare() throws IllegalStateException, RepositoryException
+   {
+      Statistics s = ALL_STATISTICS.get(PREPARE_DESCR);
+      try
+      {
+         s.begin();
+         wcs.prepare();
+      }
+      finally
+      {
+         s.end();
+      }
+   }
+   
+   /**
+    * {@inheritDoc}
+    */
    public void rollback() throws IllegalStateException, RepositoryException
    {
       Statistics s = ALL_STATISTICS.get(ROLLBACK_DESCR);
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/FileIOChannel.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/FileIOChannel.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/FileIOChannel.java	(working copy)
@@ -121,6 +121,15 @@
    /**
     * {@inheritDoc}
     */
+   public void prepare() throws IOException
+   {
+      for (ValueOperation vo : changes)
+         vo.prepare();
+   }
+   
+   /**
+    * {@inheritDoc}
+    */
    public void commit() throws IOException
    {
       try
@@ -133,6 +142,22 @@
          changes.clear();
       }
    }
+   
+   /**
+    * {@inheritDoc}
+    */
+   public void twoPhaseCommit() throws IOException
+   {
+      try
+      {
+         for (ValueOperation vo : changes)
+            vo.twoPhaseCommit();
+      }
+      finally
+      {
+         changes.clear();
+      }
+   }
 
    /**
     * {@inheritDoc}
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/CASableWriteValue.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/CASableWriteValue.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/CASableWriteValue.java	(working copy)
@@ -148,61 +148,67 @@
     * {@inheritDoc}
     */
    @Override
-   public void commit() throws IOException
+   public void prepare() throws IOException
    {
       if (fileLock != null)
+      {
+         // write VCAS record first
          try
          {
-            // write VCAS record first
-            try
+            vcas.addValue(propertyId, orderNumb, vcasHash);
+         }
+         catch (RecordAlreadyExistsException e)
+         {
+            if (tempFile != null && tempFile.exists() && !tempFile.delete())
             {
-               vcas.addValue(propertyId, orderNumb, vcasHash);
+               LOG.warn("Can't delete CAS temp file. Added to file cleaner. " + tempFile.getAbsolutePath());
+               cleaner.addFile(tempFile);
             }
-            catch (RecordAlreadyExistsException e)
-            {
-               if (tempFile != null && tempFile.exists() && !tempFile.delete())
-               {
-                  LOG.warn("Can't delete CAS temp file. Added to file cleaner. " + tempFile.getAbsolutePath());
-                  cleaner.addFile(tempFile);
-               }
-               throw new RecordAlreadyExistsException("Write error: " + e, e);
-            }
+            throw new RecordAlreadyExistsException("Write error: " + e, e);
+         }
 
-            if (!vcasFile.exists())
-            {
-               // it's new CAS Value, we have to move temp to vcas location
-               // use RENAME only, don't copy - as copy will means that destination already exists etc.
+         if (!vcasFile.exists())
+         {
+            // it's new CAS Value, we have to move temp to vcas location
+            // use RENAME only, don't copy - as copy will means that destination already exists etc.
 
-               // make sure parent dir exists
-               vcasFile.getParentFile().mkdirs();
-               // rename propetynamed file to hashnamed one
-               if (!tempFile.renameTo(vcasFile))
-               {
-                  throw new VCASException("File " + tempFile.getAbsolutePath() + " can't be renamed to VCAS-named "
-                     + vcasFile.getAbsolutePath());
-               }
-            } // else - CASed Value already exists
-
-            if (!value.isByteArray() && value instanceof StreamPersistedValueData)
+            // make sure parent dir exists
+            vcasFile.getParentFile().mkdirs();
+            // rename propetynamed file to hashnamed one
+            if (!tempFile.renameTo(vcasFile))
             {
-               // set persisted file
-               ((StreamPersistedValueData)value).setPersistedFile(vcasFile);
+               throw new VCASException("File " + tempFile.getAbsolutePath() + " can't be renamed to VCAS-named "
+                  + vcasFile.getAbsolutePath());
             }
+         } // else - CASed Value already exists
 
-         }
-         finally
+         if (!value.isByteArray() && value instanceof StreamPersistedValueData)
          {
-            // remove temp file
-            tempFile.delete(); // should be ok without file cleaner
-
-            fileLock.unlock();
+            // set persisted file
+            ((StreamPersistedValueData)value).setPersistedFile(vcasFile);
          }
+      }
    }
 
    /**
     * {@inheritDoc}
     */
    @Override
+   public void twoPhaseCommit() throws IOException
+   {
+      if (fileLock != null)
+      {
+         // remove temp file
+         tempFile.delete(); // should be ok without file cleaner
+
+         fileLock.unlock();
+      }
+   }
+
+   /**
+    * {@inheritDoc}
+    */
+   @Override
    public void rollback() throws IOException
    {
       if (fileLock != null)
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/DeleteValues.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/DeleteValues.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/DeleteValues.java	(working copy)
@@ -23,6 +23,7 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * Created by The eXo Platform SAS.
@@ -35,6 +36,7 @@
  */
 public class DeleteValues extends ValueFileOperation
 {
+   private static final AtomicLong SEQUENCE = new AtomicLong();
 
    /**
     * Files to be deleted.
@@ -47,6 +49,11 @@
    private ValueFileLock[] locks;
 
    /**
+    * The backup files
+    */
+   protected File[] bckFiles;
+
+   /**
     * DeleteValues constructor.
     * 
     * @param files
@@ -83,24 +90,61 @@
    /**
     * {@inheritDoc}
     */
+   public void prepare() throws IOException
+   {
+      if (locks != null)
+      {
+         bckFiles = new File[files.length];
+         for (int i = 0,length = files.length; i < length; i++)
+         {
+            File file = files[i];
+            if (file.exists())
+            {
+               bckFiles[i] = new File(file.getAbsolutePath() + "." + System.currentTimeMillis() + "_" + SEQUENCE.incrementAndGet());
+               if (!file.renameTo(bckFiles[i]))
+               {
+                  throw new IOException("Could not rename the file " + file.getAbsolutePath() + " to " + bckFiles[i].getAbsolutePath());
+               }
+            }           
+         }
+      }
+   }
+
+   /**
+    * {@inheritDoc}
+    */
    public void rollback() throws IOException
    {
       if (locks != null)
-         for (ValueFileLock fl : locks)
-            fl.unlock();
+         try
+         {
+            for (int i = 0,length = files.length; i < length; i++)
+            {
+               File f = bckFiles[i];
+               if (f != null)
+               {
+                  f.renameTo(files[i]);
+               }
+            }
+         }
+         finally
+         {
+            for (ValueFileLock fl : locks)
+               fl.unlock();
+         }
    }
 
    /**
     * {@inheritDoc}
     */
-   public void commit() throws IOException
+   public void twoPhaseCommit() throws IOException
    {
       if (locks != null)
          try
          {
-            for (File f : files)
+            for (File f : bckFiles)
             {
-               if (!f.delete())
+               if (f != null && !f.delete())
                   // TODO possible place of error: FileNotFoundException when we delete/update existing
                   // Value and then add/update again.
                   // After the time the Cleaner will delete the file which is mapped to the Value.
@@ -110,9 +154,8 @@
          }
          finally
          {
-            if (locks != null)
-               for (ValueFileLock fl : locks)
-                  fl.unlock();
+            for (ValueFileLock fl : locks)
+               fl.unlock();
          }
    }
 }
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/WriteValue.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/WriteValue.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/WriteValue.java	(working copy)
@@ -79,34 +79,47 @@
       fileLock = new ValueFileLock(file);
       fileLock.lock();
    }
-
-   /**
-    * {@inheritDoc}
-    */
-   public void rollback() throws IOException
+   
+   public void prepare() throws IOException
    {
       if (fileLock != null)
-         fileLock.unlock();
+      {
+         // be sure the destination dir exists (case for Tree-style storage)
+         file.getParentFile().mkdirs();
+         // write value to the file
+         writeValue(file, value);
+      }
    }
 
    /**
     * {@inheritDoc}
     */
-   public void commit() throws IOException
+   public void rollback() throws IOException
    {
       if (fileLock != null)
+      {
          try
          {
-            // be sure the destination dir exists (case for Tree-style storage)
-            file.getParentFile().mkdirs();
-
-            // write value to the file
-            writeValue(file, value);
+            if (file.exists() && !file.delete())
+            {
+               cleaner.addFile(file);
+            }
          }
          finally
          {
             fileLock.unlock();
          }
+      }
    }
 
+   /**
+    * {@inheritDoc}
+    */
+   public void twoPhaseCommit() throws IOException
+   {
+      if (fileLock != null)
+      {
+         fileLock.unlock();
+      }
+   }
 }
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/CASableDeleteValues.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/CASableDeleteValues.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/CASableDeleteValues.java	(working copy)
@@ -81,11 +81,11 @@
     * {@inheritDoc}
     */
    @Override
-   public void commit() throws IOException
+   public void prepare() throws IOException
    {
       try
       {
-         super.commit();
+         super.prepare();
       }
       finally
       {
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/ValueFileOperation.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/ValueFileOperation.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/fs/operations/ValueFileOperation.java	(working copy)
@@ -276,4 +276,19 @@
 
       performed = true;
    }
+
+   /**
+    * {@inheritDoc}
+    */
+   public void commit() throws IOException
+   {
+      try
+      {
+         prepare();         
+      }
+      finally
+      {
+         twoPhaseCommit();         
+      }
+   }
 }
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/ValueOperation.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/ValueOperation.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/impl/storage/value/ValueOperation.java	(working copy)
@@ -49,11 +49,26 @@
    void rollback() throws IOException;
 
    /**
-    * Commit Value content.
+    * Commit Value content (one phase).
     * 
     * @throws IOException
     *           if error occurs
     */
    void commit() throws IOException;
 
+   /**
+    * Prepare Value content.
+    * 
+    * @throws IOException
+    *           if error occurs
+    */
+   void prepare() throws IOException;
+   
+   /**
+    * Commit Value content (two phases).
+    * 
+    * @throws IOException
+    *           if error occurs
+    */
+   void twoPhaseCommit() throws IOException;
 }
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/storage/WorkspaceStorageConnection.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/storage/WorkspaceStorageConnection.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/storage/WorkspaceStorageConnection.java	(working copy)
@@ -38,7 +38,7 @@
  * should have "opened" state. The connection becomes "closed" (invalid for using) after calling
  * commit() or rollback() methods. In this case methods calling will cause an IllegalStateException
  * 
- * Connection object intendend to be as "light" as possible i.e. connection creation SHOULD NOT be
+ * Connection object intends to be as "light" as possible i.e. connection creation SHOULD NOT be
  * expensive operation, so better NOT to open/close potentially EXPENSIVE resources using by
  * Connection (WorkspaceDataContainer should be responsible for that). The Connection IS NOT a
  * thread-safe object and normally SHOULD NOT be pooled/cached.
@@ -57,10 +57,10 @@
     *          - the item's parent NodeData
     * @param name
     *          - item's path entry (QName + index)
-    * @return - stored ItemData wich has exact the same path Entry (name+index) inside the parent; or
+    * @return - stored ItemData which has exact the same path Entry (name+index) inside the parent; or
     *         null if not such an item data found
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     */
@@ -77,10 +77,10 @@
     *          - item's path entry (QName + index)
     * @param itemType
     *             item type         
-    * @return - stored ItemData wich has exact the same path Entry (name+index) inside the parent; or
+    * @return - stored ItemData which has exact the same path Entry (name+index) inside the parent; or
     *         null if not such an item data found
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     */
@@ -92,12 +92,12 @@
     * 
     * @param identifier
     *          - Item identifier
-    * @return stored ItemData or null if no item foudn with given id. Basically used for
+    * @return stored ItemData or null if no item found with given id. Basically used for
     *         Session.getNodeByUUID but not necessarily refers to jcr:uuid property (In fact, this
     *         identifier should not necessary be equal of referenceable node's UUID if any) thereby
     *         can return NodeData for not referenceable node data or PropertyData.
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     */
@@ -110,7 +110,7 @@
     *          NodeData
     * @return child nodes data or empty <code>List</code>
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     */
@@ -142,7 +142,7 @@
     *          NodeData
     * @return child properties data or empty <code>List</code>
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     */
@@ -153,13 +153,13 @@
     * storage using item's parent location.
     * 
     * <br/>
-    * This methiod specially dedicated for non-content modification operations (e.g. Items delete).
+    * This method specially dedicated for non-content modification operations (e.g. Items delete).
     * 
     * @param parent
     *          NodeData
     * @return child properties data (with empty data) or empty <code>List</code>
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     */
@@ -178,7 +178,7 @@
     *          of referenceable Node
     * @return list of referenced property data or empty <code>List</code>
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     * @throws UnsupportedOperationException
@@ -197,7 +197,7 @@
     * @throws UnsupportedOperationException
     *           if operation is not supported (it is container for level 1)
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     */
@@ -214,7 +214,7 @@
     * @throws UnsupportedOperationException
     *           if operation is not supported (it is container for level 1)
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     */
@@ -229,12 +229,12 @@
     * @throws InvalidItemStateException
     *           (1)if the data is already updated, i.e. persisted version value of persisted data >=
     *           of new data's persisted version value (2) if the persisted data is not NodeData (i.e.
-    *           it is PropertyData). It means that some other proccess deleted original data and
+    *           it is PropertyData). It means that some other process deleted original data and
     *           replace it with other type of data.
     * @throws UnsupportedOperationException
     *           if operation is not supported (it is container for level 1)
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     */
@@ -249,12 +249,12 @@
     * @throws InvalidItemStateException
     *           (1)if the data is already updated, i.e. persisted version value of persisted data >=
     *           of new data's persisted version value (2) if the persisted data is not PropertyData
-    *           (i.e. it is NodeData). It means that some other proccess deleted original data and
+    *           (i.e. it is NodeData). It means that some other process deleted original data and
     *           replace it with other type of data.
     * @throws UnsupportedOperationException
     *           if operation is not supported (it is container for level 1)
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     */
@@ -269,12 +269,12 @@
     * @throws InvalidItemStateException
     *           (1)if the data is already updated, i.e. persisted version value of persisted data >=
     *           of new data's persisted version value (2) if the persisted data is not PropertyData
-    *           (i.e. it is NodeData). It means that some other proccess deleted original data and
+    *           (i.e. it is NodeData). It means that some other process deleted original data and
     *           replace it with other type of data.
     * @throws UnsupportedOperationException
     *           if operation is not supported (it is container for level 1)
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     */
@@ -292,7 +292,7 @@
     * @throws UnsupportedOperationException
     *           if operation is not supported (it is container for level 1)
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     */
@@ -310,7 +310,7 @@
     * @throws UnsupportedOperationException
     *           if operation is not supported (it is container for level 1)
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     * @throws IllegalStateException
     *           if connection is closed
     */
@@ -318,23 +318,33 @@
       IllegalStateException;
 
    /**
+    * Prepare the commit phase.
+    * 
+    * @throws IllegalStateException
+    *           if connection is already closed
+    * @throws RepositoryException
+    *           if some exception occurred
+    */
+   void prepare() throws IllegalStateException, RepositoryException;
+   
+   /**
     * Persist changes and closes connection. It can be database transaction commit for instance etc.
     * 
     * @throws IllegalStateException
     *           if connection is already closed
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     */
    void commit() throws IllegalStateException, RepositoryException;
 
    /**
-    * Refuses persistent changes and closes connection. It can be database transaction rollback for
+    * Refuses persistent changes and closes connection. It can be database transaction roll back for
     * instance etc.
     * 
     * @throws IllegalStateException
     *           if connection is already closed
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     */
    void rollback() throws IllegalStateException, RepositoryException;
 
@@ -344,7 +354,7 @@
     * @throws IllegalStateException
     *           if connection is already closed
     * @throws RepositoryException
-    *           if some exception occured
+    *           if some exception occurred
     */
    void close() throws IllegalStateException, RepositoryException;
 
Index: exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/storage/value/ValueIOChannel.java
===================================================================
--- exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/storage/value/ValueIOChannel.java	(revision 5842)
+++ exo.jcr.component.core/src/main/java/org/exoplatform/services/jcr/storage/value/ValueIOChannel.java	(working copy)
@@ -78,12 +78,28 @@
    String getStorageId();
 
    /**
-    * Commit channel changes.
+    * Prepare channel changes.
     * 
     * @throws IOException
     *           if error occurs
     */
+   void prepare() throws IOException;
+   
+   /**
+    * Commit channel changes (one phase).
+    * 
+    * @throws IOException
+    *           if error occurs
+    */
    void commit() throws IOException;
+   
+   /**
+    * Commit channel changes (two phases).
+    * 
+    * @throws IOException
+    *           if error occurs
+    */
+   void twoPhaseCommit() throws IOException;
 
    /**
     * Rollback channel changes.
Index: exo.jcr.component.core/src/main/resources/conf/portal/cluster/jbosscache-lock.xml
===================================================================
--- exo.jcr.component.core/src/main/resources/conf/portal/cluster/jbosscache-lock.xml	(revision 5842)
+++ exo.jcr.component.core/src/main/resources/conf/portal/cluster/jbosscache-lock.xml	(working copy)
@@ -18,7 +18,7 @@
 			For another cache-loader class you should use another template with
 			cache-loader specific parameters
 		-->
-      <loader class="org.jboss.cache.loader.JDBCCacheLoader" async="false" fetchPersistentState="false"
+      <loader class="org.exoplatform.services.jcr.impl.core.lock.jbosscache.JDBCCacheLoader" async="false" fetchPersistentState="false"
          ignoreModifications="false" purgeOnStartup="false">
          <properties>
             cache.jdbc.table.name=${jbosscache-cl-cache.jdbc.table.name}
Index: exo.jcr.component.ext/src/test/java/org/exoplatform/services/jcr/ext/BaseStandaloneTest.java
===================================================================
--- exo.jcr.component.ext/src/test/java/org/exoplatform/services/jcr/ext/BaseStandaloneTest.java	(revision 5842)
+++ exo.jcr.component.ext/src/test/java/org/exoplatform/services/jcr/ext/BaseStandaloneTest.java	(working copy)
@@ -295,60 +295,67 @@
    protected void compareStream(InputStream etalon, InputStream data, long etalonPos, long dataPos, long length)
       throws IOException, CompareStreamException
    {
+      try
+      {
+         int dindex = 0;
 
-      int dindex = 0;
+         skipStream(etalon, etalonPos);
+         skipStream(data, dataPos);
 
-      skipStream(etalon, etalonPos);
-      skipStream(data, dataPos);
+         byte[] ebuff = new byte[1024];
+         int eread = 0;
 
-      byte[] ebuff = new byte[1024];
-      int eread = 0;
+         while ((eread = etalon.read(ebuff)) > 0)
+         {
 
-      while ((eread = etalon.read(ebuff)) > 0)
-      {
-
-         byte[] dbuff = new byte[eread];
-         int erindex = 0;
-         while (erindex < eread)
-         {
-            int dread = -1;
-            try
+            byte[] dbuff = new byte[eread];
+            int erindex = 0;
+            while (erindex < eread)
             {
-               dread = data.read(dbuff);
-            }
-            catch (IOException e)
-            {
-               throw new CompareStreamException("Streams is not equals by length or data stream is unreadable. Cause: "
-                  + e.getMessage());
-            }
+               int dread = -1;
+               try
+               {
+                  dread = data.read(dbuff);
+               }
+               catch (IOException e)
+               {
+                  throw new CompareStreamException(
+                     "Streams is not equals by length or data stream is unreadable. Cause: " + e.getMessage());
+               }
 
-            if (dread == -1)
-               throw new CompareStreamException(
-                  "Streams is not equals by length. Data end-of-stream reached at position " + dindex);
+               if (dread == -1)
+                  throw new CompareStreamException(
+                     "Streams is not equals by length. Data end-of-stream reached at position " + dindex);
 
-            for (int i = 0; i < dread; i++)
-            {
-               byte eb = ebuff[i];
-               byte db = dbuff[i];
-               if (eb != db)
-                  throw new CompareStreamException("Streams is not equals. Wrong byte stored at position " + dindex
-                     + " of data stream. Expected 0x" + Integer.toHexString(eb) + " '" + new String(new byte[]{eb})
-                     + "' but found 0x" + Integer.toHexString(db) + " '" + new String(new byte[]{db}) + "'");
+               for (int i = 0; i < dread; i++)
+               {
+                  byte eb = ebuff[i];
+                  byte db = dbuff[i];
+                  if (eb != db)
+                     throw new CompareStreamException("Streams is not equals. Wrong byte stored at position " + dindex
+                        + " of data stream. Expected 0x" + Integer.toHexString(eb) + " '" + new String(new byte[]{eb})
+                        + "' but found 0x" + Integer.toHexString(db) + " '" + new String(new byte[]{db}) + "'");
 
-               erindex++;
-               dindex++;
-               if (length > 0 && dindex >= length)
-                  return; // tested length reached
+                  erindex++;
+                  dindex++;
+                  if (length > 0 && dindex >= length)
+                     return; // tested length reached
+               }
+
+               if (dread < eread)
+                  dbuff = new byte[eread - dread];
             }
+         }
 
-            if (dread < eread)
-               dbuff = new byte[eread - dread];
-         }
+         if (data.available() > 0)
+            throw new CompareStreamException(
+               "Streams is not equals by length. Data stream contains more data. Were read " + dindex);
       }
-
-      if (data.available() > 0)
-         throw new CompareStreamException("Streams is not equals by length. Data stream contains more data. Were read "
-            + dindex);
+      finally
+      {
+         etalon.close();
+         data.close();
+      }
    }
 
    protected void skipStream(InputStream stream, long pos) throws IOException
Index: exo.jcr.component.ext/src/test/java/org/exoplatform/services/jcr/ext/backup/AbstractBackupUseCasesTest.java
===================================================================
--- exo.jcr.component.ext/src/test/java/org/exoplatform/services/jcr/ext/backup/AbstractBackupUseCasesTest.java	(revision 5842)
+++ exo.jcr.component.ext/src/test/java/org/exoplatform/services/jcr/ext/backup/AbstractBackupUseCasesTest.java	(working copy)
@@ -16,26 +16,29 @@
  */
 package org.exoplatform.services.jcr.ext.backup;
 
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.List;
+import java.util.Map;
+
+import javax.jcr.Node;
+
 import org.apache.commons.collections.map.HashedMap;
 import org.exoplatform.services.jcr.config.RepositoryEntry;
+import org.exoplatform.services.jcr.config.SimpleParameterEntry;
 import org.exoplatform.services.jcr.config.WorkspaceEntry;
 import org.exoplatform.services.jcr.core.ManageableRepository;
 import org.exoplatform.services.jcr.ext.backup.impl.JobRepositoryRestore;
 import org.exoplatform.services.jcr.ext.backup.impl.JobWorkspaceRestore;
-import org.exoplatform.services.jcr.impl.core.RepositoryImpl;
+import org.exoplatform.services.jcr.impl.Constants;
 import org.exoplatform.services.jcr.impl.core.SessionImpl;
+import org.exoplatform.services.jcr.util.IdGenerator;
+import org.exoplatform.services.jcr.util.TesterConfigurationHelper;
 
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.util.Map;
-
-import javax.jcr.Node;
-import javax.jcr.RepositoryException;
-import javax.jcr.Session;
-import javax.jcr.Value;
-import javax.jcr.lock.Lock;
-
 /**
  * Created by The eXo Platform SAS.
  * 
@@ -44,613 +47,246 @@
  * @author <a href="mailto:alex.reshetnyak@exoplatform.com.ua">Alex Reshetnyak</a> 
  * @version $Id: AbstractBackupUseCasesTest.java 3709 2010-12-22 11:56:25Z tolusha $
  */
-public abstract class AbstractBackupUseCasesTest
-   extends AbstractBackupTestCase
+public abstract class AbstractBackupUseCasesTest extends AbstractBackupTestCase
 {
 
-   private static volatile long uuIndex;
+   protected TesterConfigurationHelper helper = TesterConfigurationHelper.getInstance();
 
-   protected static synchronized long getUUIndex()
+   File blob;
+
+   public void setUp() throws Exception
    {
-      return uuIndex++;
+      super.setUp();
+      blob = createBLOBTempFile(300);
    }
 
    public void testFullBackupRestore() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+      addConent(repository, wsEntry.getName());
+
       // backup
-      File backDir = new File("target/backup/" + workspaceNameToBackup + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
-
       // restore
-      RepositoryEntry re =
-               (RepositoryEntry) ws1Session.getContainer().getComponentInstanceOfType(RepositoryEntry.class);
-      WorkspaceEntry ws1back = makeWorkspaceEntry(workspaceNameToRestore, dataSourceToWorkspaceRestore);
+      WorkspaceEntry newWS = helper.createWorkspaceEntry(true, null);
 
-      // BackupChainLog bchLog = new BackupChainLog(backDir, rconfig);
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-         backup.restore(bchLog, re.getName(), ws1back, false);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 = (SessionImpl) getReposityToBackup().login(credentials, workspaceNameToRestore);
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-            assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                     .getProperty("exo:data").getString());
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restore(bchLog, config.getRepository(), newWS, false);
+      checkConent(repository, newWS.getName());
    }
 
    public void testIncrementalBackupRestore() throws Exception
    {
-      // full backup & incremental
-      File backDir = new File("target/backup/" + workspaceNameToBackup + getUUIndex());
-      backDir.mkdirs();
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+      addConent(repository, wsEntry.getName());
 
-      BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
-      config.setBackupType(BackupManager.FULL_AND_INCREMENTAL);
-
-      config.setBackupDir(backDir);
-
-      backup.startBackup(config);
-
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // add some changes which will be logged in incremental log
-      ws1TestRoot.getNode("node_3").remove();
-      ws1TestRoot.getNode("node_4").remove();
-      ws1TestRoot.getNode("node_5").remove();
-      ws1TestRoot.addNode("node #3").setProperty("exo:data", "property #3");
-      ws1TestRoot.addNode("node #5").setProperty("exo:extraData", "property #5");
-      
-      ws1TestRoot.addNode("binary_data").setProperty("data", new FileInputStream(createBLOBTempFile(500)));
-
-      ws1TestRoot.save(); // log here via listener
-
-      // stop all
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
-
-      // restore
-      RepositoryEntry re =
-               (RepositoryEntry) ws1Session.getContainer().getComponentInstanceOfType(RepositoryEntry.class);
-      WorkspaceEntry ws1back = makeWorkspaceEntry(workspaceNameToRestore, dataSourceToWorkspaceRestore);
-
-      File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
-
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
-
-         backup.restore(bchLog, repositoryNameToBackup, ws1back, false);
-
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 = (SessionImpl) getReposityToBackup().login(credentials, workspaceNameToRestore);
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-            assertFalse("Node should be removed", ws1backTestRoot.hasNode("node_3"));
-            assertFalse("Node should be removed", ws1backTestRoot.hasNode("node_4"));
-            assertFalse("Node should be removed", ws1backTestRoot.hasNode("node_5"));
-
-            assertEquals("Restored content should be same", "property #3", ws1backTestRoot.getNode("node #3")
-                     .getProperty("exo:data").getString());
-            assertEquals("Restored content should be same", "property #5", ws1backTestRoot.getNode("node #5")
-                     .getProperty("exo:extraData").getString());
-
-            assertFalse("Proeprty should be removed", ws1backTestRoot.getNode("node #5").hasProperty("exo:data"));
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
-   }
-
-   public void testIncrementalBackupRestore2() throws Exception
-   {
-      // full backup with BLOBs & incremental with BLOBs
-
-      // BLOBs for full
-      File tempf = createBLOBTempFile("testIncrementalBackupRestore2-", 5 * 1024); // 5M
-      tempf.deleteOnExit();
-      ws1TestRoot.addNode("node_101").setProperty("exo:data", new FileInputStream(tempf));
-      ws1TestRoot.addNode("node_102").setProperty("exo:extraData", new FileInputStream(tempf));
-
-      File backDir = new File("target/backup/" + workspaceNameToBackup + getUUIndex());
+      // backup
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
       config.setBackupType(BackupManager.FULL_AND_INCREMENTAL);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
 
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
+      addIncrementalConent(repository, wsEntry.getName());
 
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
+      backup.stopBackup(bch);
 
-      // add some changes which will be logged in incremental log
-      ws1TestRoot.addNode("node #53").setProperty("exo:extraData", "property #53");
-      ws1TestRoot.save(); // log here via listener
-
-      // BLOBs for incr
-      ws1TestRoot.getNode("node_1").setProperty("exo:extraData", new FileInputStream(tempf));
-      ws1TestRoot.getNode("node_5").setProperty("exo:data", new FileInputStream(tempf));
-
-      ws1TestRoot.addNode("node_101").setProperty("exo:data", new FileInputStream(tempf));
-      ws1TestRoot.addNode("node_102").setProperty("exo:data", new FileInputStream(tempf));
-      ws1TestRoot.save(); // log here via listener
-
-      ws1TestRoot.getNode("node_2").setProperty("exo:data", (Value) null); // remove property
-      ws1TestRoot.getNode("node_3").setProperty("exo:data", new ByteArrayInputStream("aaa".getBytes())); // set
-      // aaa
-      // bytes
-      ws1TestRoot.getNode("node_4").remove(); // (*)
-      ws1TestRoot.save(); // log here via listener
-
-      ws1TestRoot.getNode("node_5").addMixin("mix:lockable");
-      ws1TestRoot.save(); // log here via listener
-      Lock n107lock = ws1TestRoot.getNode("node_5").lock(true, false);
-      ws1TestRoot.getSession().move(ws1TestRoot.getNode("node #53").getPath(),
-               ws1TestRoot.getNode("node_5").getPath() + "/node #53");
-      ws1TestRoot.save(); // log here via listener
-
-      ws1TestRoot.getNode("node_6").addMixin("mix:referenceable");
-      String id6 = ws1TestRoot.getNode("node_6").getUUID();
-      ws1TestRoot.save(); // log here via listener
-
-      // before(*), log here via listener
-      ws1TestRoot.getSession().getWorkspace().move(ws1TestRoot.getNode("node_6").getPath(),
-               ws1TestRoot.getPath() + "/node_4"); // in place of
-      // 4 removed
-
-      // stop all
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
-
       // restore
-      RepositoryEntry re =
-               (RepositoryEntry) ws1Session.getContainer().getComponentInstanceOfType(RepositoryEntry.class);
-      WorkspaceEntry ws1back = makeWorkspaceEntry(workspaceNameToRestore, dataSourceToWorkspaceRestore);
+      WorkspaceEntry newWS = helper.createWorkspaceEntry(true, null);
 
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-         backup.restore(bchLog, repositoryNameToBackup, ws1back, false);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 = (SessionImpl) getReposityToBackup().login(credentials, workspaceNameToRestore);
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-
-            assertTrue("Node should exists", ws1backTestRoot.getNode("node_5").hasNode("node #53"));
-            assertTrue("Property should exists", ws1backTestRoot.getNode("node_5")
-                     .hasProperty("node #53/exo:extraData"));
-
-            assertTrue("Node should exists", ws1backTestRoot.hasNode("node_7"));
-            assertTrue("Property should exists", ws1backTestRoot.hasProperty("node_5/exo:data"));
-            assertTrue("Property should exists", ws1backTestRoot.hasProperty("node_1/exo:extraData"));
-            assertTrue("Node should exists", ws1backTestRoot.hasNode("node_102"));
-
-            compareStream(new FileInputStream(tempf), ws1backTestRoot.getNode("node_5").getProperty("exo:data")
-                     .getStream());
-            compareStream(new FileInputStream(tempf), ws1backTestRoot.getNode("node_1").getProperty("exo:extraData")
-                     .getStream());
-
-            assertFalse("Property should be removed", ws1backTestRoot.getNode("node_2").hasProperty("exo:data"));
-
-            compareStream(new ByteArrayInputStream("aaa".getBytes()), ws1backTestRoot.getNode("node_3").getProperty(
-                     "exo:data").getStream());
-
-            assertTrue("Node should be mix:lockable ", ws1backTestRoot.getNode("node_5").isNodeType("mix:lockable"));
-            assertFalse("Node should be not locked ", ws1backTestRoot.getNode("node_5").isLocked());
-
-            assertEquals("Node should be mix:referenceable and UUID should be " + id6, id6, ws1backTestRoot.getNode(
-                     "node_4").getUUID());
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restore(bchLog, config.getRepository(), newWS, false);
+      checkConent(repository, newWS.getName());
+      checkIncrementalConent(repository, newWS.getName());
    }
 
    public void testFullBackupRestoreAsync() throws Exception
    {
-      SessionImpl sessionWS1 = (SessionImpl) getReposityToBackup().login(credentials, workspaceNameToBackup);
-      sessionWS1.getRootNode().getNode("backupTest").getNode("node_5").setProperty("exo:data",
-               "Restored content should be same");
-      sessionWS1.save();
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+      addConent(repository, wsEntry.getName());
 
       // backup
-      File backDir = new File("target/backup/" + workspaceNameToBackup + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
-
       // restore
-      WorkspaceEntry ws1back = makeWorkspaceEntry(workspaceNameToRestore, dataSourceToWorkspaceRestore);
+      WorkspaceEntry newWS = helper.createWorkspaceEntry(true, null);
 
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-         backup.restore(bchLog, repositoryNameToBackup, ws1back, true);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         while (backup.getLastRestore(repositoryNameToBackup, workspaceNameToRestore).getStateRestore() != JobWorkspaceRestore.RESTORE_SUCCESSFUL
-                  && backup.getLastRestore(repositoryNameToBackup, workspaceNameToRestore).getStateRestore() != JobWorkspaceRestore.RESTORE_FAIL)
-         {
-            Thread.sleep(50);
-         }
+      backup.restore(bchLog, config.getRepository(), newWS, true);
+      waitEndOfRestore(config.getRepository(), newWS.getName());
 
-         if (backup.getLastRestore(repositoryNameToBackup, workspaceNameToRestore).getStateRestore() == JobWorkspaceRestore.RESTORE_FAIL)
-            throw (Exception) backup.getLastRestore(repositoryNameToBackup, workspaceNameToRestore)
-                     .getRestoreException();
-
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 = (SessionImpl) getReposityToBackup().login(credentials, workspaceNameToRestore);
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-            assertEquals("Restored content should be same", "Restored content should be same", ws1backTestRoot.getNode(
-                     "node_5").getProperty("exo:data").getString());
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      assertEquals(backup.getLastRestore(config.getRepository(), newWS.getName()).getStateRestore(),
+         JobWorkspaceRestore.RESTORE_SUCCESSFUL);
+      checkConent(repository, newWS.getName());
    }
 
    public void testAutoStopBackupFull() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+
       // backup
-      File backDir = new File("target/backup/" + workspaceNameToBackup + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
       BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
 
-      while (!bch.isFinished())
+      Thread.sleep(30000);
+      try
       {
-         Thread.yield();
-         Thread.sleep(50);
+         assertEquals(backup.getCurrentBackups().size(), 0);
       }
-
-      Thread.sleep(5000);
-
-      for (BackupChain chain : backup.getCurrentBackups())
-         if (bch.getBackupId().equals(chain.getBackupId()))
-            fail("The backup with id '" + chain.getBackupId() + "' should not be active");
+      finally
+      {
+         backup.stopBackup(bch);
+      }
    }
 
    public void testAutoStopBackupIncr() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+
       // backup
-      File backDir = new File("target/backup/" + workspaceNameToBackup + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
       config.setBackupType(BackupManager.FULL_AND_INCREMENTAL);
-      config.setBackupDir(backDir);
       config.setIncrementalJobPeriod(3);
       config.setIncrementalJobNumber(0);
+      config.setBackupDir(backDir);
 
       BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
 
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
+      Thread.sleep(10000);
+      try
       {
-         Thread.yield();
-         Thread.sleep(50);
+         assertEquals(backup.getCurrentBackups().size(), 1);
       }
-
-      boolean isFail = true;
-
-      for (BackupChain chain : backup.getCurrentBackups())
-         if (bch.getBackupId().equals(chain.getBackupId()))
-            isFail = false;
-
-      if (isFail)
-         fail("The backup with id '" + bch.getBackupId() + "' should be active");
-
-      backup.stopBackup(bch);
+      finally
+      {
+         backup.stopBackup(bch);
+      }
    }
 
-   public void testAutoStopBackupIncrRepetion() throws Exception
+   public void _testAutoStopBackupIncrRepetion() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+
       // backup
-      File backDir = new File("target/backup/" + workspaceNameToBackup + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
       config.setBackupType(BackupManager.FULL_AND_INCREMENTAL);
-      config.setBackupDir(backDir);
       config.setIncrementalJobPeriod(4);
       config.setIncrementalJobNumber(2);
+      config.setBackupDir(backDir);
 
-      final BackupChain bch = backup.startBackup(config);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
 
-      while (!bch.isFinished())
+      Thread.sleep(60000);
+      try
       {
-         Thread.yield();
-         Thread.sleep(50);
+         assertEquals(backup.getCurrentBackups().size(), 0);
       }
-
-      Thread.sleep(5000);
-
-      for (BackupChain chain : backup.getCurrentBackups())
-         if (bch.getBackupId().equals(chain.getBackupId()))
-            fail("The backup with id '" + chain.getBackupId() + "' should not be active");
-   }
-
-   public void testTwoRestores() throws Exception
-   {
+      finally
       {
-         SessionImpl sessionWS1 = (SessionImpl) getReposityToBackup().login(credentials, workspaceNameToBackup);
-
-         sessionWS1.getRootNode().addNode("asdasdasda", "nt:unstructured").setProperty("data",
-                  new FileInputStream(createBLOBTempFile(1024)));
-         sessionWS1.save();
-
-         // 1-st backup
-         File backDir = new File("target/backup/" + workspaceNameToBackup + getUUIndex());
-         backDir.mkdirs();
-
-         BackupConfig config = new BackupConfig();
-         config.setRepository(repositoryNameToBackup);
-         config.setWorkspace(workspaceNameToBackup);
-         config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-         config.setBackupDir(backDir);
-
-         BackupChain bch = backup.startBackup(config);
-
-         // wait till full backup will be stopped
-         while (!bch.isFinished())
-         {
-            Thread.yield();
-            Thread.sleep(50);
-         }
-
-         // 1-st restore
-         WorkspaceEntry ws1_restore_1 = makeWorkspaceEntry(workspaceNameToRestore, dataSourceToWorkspaceRestore);
-
-         File backLog = new File(bch.getLogFilePath());
-         if (backLog.exists())
-         {
-            BackupChainLog bchLog = new BackupChainLog(backLog);
-
-            backup.restore(bchLog, repositoryNameToBackup, ws1_restore_1, false);
-
-            // check
-            SessionImpl back1 = (SessionImpl) getReposityToBackup().login(credentials, workspaceNameToRestore);
-            assertNotNull(back1.getRootNode().getNode("asdasdasda").getProperty("data"));
-
-            // add date to restored workspace
-            back1.getRootNode().addNode("gdfgrghfhf", "nt:unstructured").setProperty("data",
-                     new FileInputStream(createBLOBTempFile(1024)));
-            back1.save();
-         }
-         else
-            fail("There are no backup files in " + backDir.getAbsolutePath());
+         backup.stopBackup(bch);
       }
-
-      {
-         // 2-st backup
-         File backDir = new File("target/backup/" + workspaceNameToBackup + getUUIndex());
-         backDir.mkdirs();
-
-         BackupConfig config = new BackupConfig();
-         config.setRepository(repositoryNameToBackup);
-         config.setWorkspace(workspaceNameToRestore);
-         config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-         config.setBackupDir(backDir);
-
-         BackupChain bch = backup.startBackup(config);
-
-         // wait till full backup will be stopped
-         while (!bch.isFinished())
-         {
-            Thread.yield();
-            Thread.sleep(50);
-         }
-
-         removeWorkspaceFully(repositoryNameToBackup, workspaceNameToRestore);
-
-         // 2-st restore
-         WorkspaceEntry ws1_restore_2 = makeWorkspaceEntry(workspaceNameToRestore, dataSourceToWorkspaceRestore);
-
-         File backLog = new File(bch.getLogFilePath());
-         if (backLog.exists())
-         {
-            BackupChainLog bchLog = new BackupChainLog(backLog);
-
-            backup.restore(bchLog, repositoryNameToBackup, ws1_restore_2, false);
-
-            // check
-            SessionImpl back2 = (SessionImpl) getReposityToBackup().login(credentials, workspaceNameToRestore);
-            assertNotNull(back2.getRootNode().getNode("gdfgrghfhf").getProperty("data"));
-         }
-         else
-            fail("There are no backup files in " + backDir.getAbsolutePath());
-      }
    }
 
-   public void testStartFullBackupWIthJobPeriod() throws Exception
-   {
-      // backup
-      File backDir = new File("target/backup" + workspaceNameToBackup + getUUIndex());
-      backDir.mkdirs();
-
-      BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
-      config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-      config.setBackupDir(backDir);
-      config.setIncrementalJobPeriod(3600);
-
-      backup.startBackup(config);
-
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-   }
-
    public void testNegativeIncremetalJobPeriod() throws Exception
    {
       // backup
-      File backDir = new File("target/backup/ws1_negative_period" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository("fake");
+      config.setWorkspace("fake");
       config.setBackupType(BackupManager.FULL_AND_INCREMENTAL);
       config.setIncrementalJobPeriod(-1000);
-
       config.setBackupDir(backDir);
 
       try
@@ -660,22 +296,20 @@
       }
       catch (BackupConfigurationException e)
       {
-         //ok
       }
    }
 
    public void testNegativeIncremetalJobNumber() throws Exception
    {
       // backup
-      File backDir = new File("target/backup/ws1_negative_job_number" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository("fake");
+      config.setWorkspace("fake");
       config.setBackupType(BackupManager.FULL_AND_INCREMENTAL);
       config.setIncrementalJobNumber(-5);
-
       config.setBackupDir(backDir);
 
       try
@@ -685,2051 +319,1233 @@
       }
       catch (BackupConfigurationException e)
       {
-         //ok
       }
    }
 
-   public void testRestoreAfterFAilureRestore() throws Exception
+   public void testRestoreAfterFailureRestore() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+      addConent(repository, wsEntry.getName());
+
       // backup
-      File backDir = new File("target/backup/" + workspaceNameToBackup + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
-
       // restore
-      RepositoryEntry re =
-               (RepositoryEntry) ws1Session.getContainer().getComponentInstanceOfType(RepositoryEntry.class);
-      WorkspaceEntry ws1back = makeWorkspaceEntry(workspaceNameToRestore, dataSourceToWorkspaceRestore + "NOT_EXIST");
+      WorkspaceEntry newWS = helper.createWorkspaceEntry(true, "NOT_EXISTED_DS");
 
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         try
-         {
-            backup.restore(bchLog, repositoryNameToBackup, ws1back, false);
-            fail("The backup can not be restored.");
-         }
-         catch (Exception e)
-         {
-            //ok
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-            WorkspaceEntry ws1backTwo = makeWorkspaceEntry(workspaceNameToRestore, dataSourceToWorkspaceRestore);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-            backup.restore(bchLog, repositoryNameToBackup, ws1backTwo, false);
-         }
-
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 = (SessionImpl) getReposityToBackup().login(credentials, workspaceNameToRestore);
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-            assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                     .getProperty("exo:data").getString());
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
+      try
+      {
+         backup.restore(bchLog, config.getRepository(), newWS, false);
+         fail("Exception should be thrown");
       }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      catch (Exception e)
+      {
+      }
+
+      newWS = helper.createWorkspaceEntry(true, null);
+      backup.restore(bchLog, config.getRepository(), newWS, false);
+
+      checkConent(repository, newWS.getName());
    }
 
    public void testRepositoryFullBackupRestore() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
-
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
       backup.stopBackup(bch);
 
       // restore
-      RepositoryEntry newRepositoryEntry =
-               makeRepositoryEntry(repositoryNameToRestore, getReposityToBackup().getConfiguration(),
-                        dataSourceToRepositoryRestore, null);
+      RepositoryEntry newRE =
+         helper.createRepositoryEntry(true, repository.getConfiguration().getSystemWorkspaceName(), null);
 
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
-         backup.restore(bchLog, newRepositoryEntry, false);
-         assertEquals(JobWorkspaceRestore.RESTORE_SUCCESSFUL, backup.getLastRepositoryRestore(
-                  newRepositoryEntry.getName()).getStateRestore());
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         // check
-         ManageableRepository restoredRepository = repositoryService.getRepository(repositoryNameToRestore);
-
-         for (String wsName : restoredRepository.getWorkspaceNames())
-         {
-            SessionImpl back1 = null;
-            try
-            {
-               back1 = (SessionImpl) restoredRepository.login(credentials, wsName);
-               Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-               assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                        .getProperty("exo:data").getString());
-            }
-            catch (Exception e)
-            {
-               e.printStackTrace();
-               fail(e.getMessage());
-            }
-            finally
-            {
-               if (back1 != null)
-                  back1.logout();
-            }
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restore(bchLog, newRE, false);
+      checkConent(repositoryService.getRepository(newRE.getName()), newRE.getSystemWorkspaceName());
    }
 
    public void testRepositoryFullAndIncrementalBackupRestore() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_AND_INCREMENTAL);
-      config.setIncrementalJobPeriod(1000);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
 
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackup);
+      addIncrementalConent(repository, repository.getConfiguration().getSystemWorkspaceName());
 
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FULL_BACKUP_FINISHED_INCREMENTAL_BACKUP_WORKING)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      //will be saved in incremental backup
-      Session wsSession = getReposityToBackup().login(credentials, "ws");
-      wsSession.getRootNode().getNode("backupTest").addNode("binary_data")
-               .setProperty("data",
-               new FileInputStream(createBLOBTempFile(500)));
-      wsSession.save();
-
-      // stop fullBackup
-
       backup.stopBackup(bch);
 
       // restore
-      RepositoryEntry newRepositoryEntry =
-               makeRepositoryEntry(repositoryNameToRestore, getReposityToBackup().getConfiguration(),
-                        dataSourceToRepositoryRestore, null);
+      RepositoryEntry newRE =
+         helper.createRepositoryEntry(true, repository.getConfiguration().getSystemWorkspaceName(), null);
 
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
-         backup.restore(bchLog, newRepositoryEntry, false);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         // check
-         ManageableRepository restoredRepository = repositoryService.getRepository(repositoryNameToRestore);
-
-         for (String wsName : restoredRepository.getWorkspaceNames())
-         {
-            SessionImpl back1 = null;
-            try
-            {
-               back1 = (SessionImpl) restoredRepository.login(credentials, wsName);
-               Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-               assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                        .getProperty("exo:data").getString());
-               
-               if (wsName.equals("ws"))
-               {
-                  assertNotNull(ws1backTestRoot.getNode("binary_data"));
-                  assertNotNull(ws1backTestRoot.getNode("binary_data").getProperty("data"));
-               }
-            }
-            catch (Exception e)
-            {
-               e.printStackTrace();
-               fail(e.getMessage());
-            }
-            finally
-            {
-               if (back1 != null)
-                  back1.logout();
-            }
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restore(bchLog, newRE, false);
+      checkConent(repositoryService.getRepository(newRE.getName()), newRE.getSystemWorkspaceName());
+      checkIncrementalConent(repositoryService.getRepository(newRE.getName()), newRE.getSystemWorkspaceName());
    }
 
    public void testRepositoryFullBackupAsynchronusRestore() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
-
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
       backup.stopBackup(bch);
 
       // restore
-      RepositoryEntry newRepositoryEntry =
-               makeRepositoryEntry(repositoryNameToRestore, getReposityToBackup().getConfiguration(),
-                        dataSourceToRepositoryRestore, null);
+      RepositoryEntry newRE =
+         helper.createRepositoryEntry(true, repository.getConfiguration().getSystemWorkspaceName(), null);
 
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
-         backup.restore(bchLog, newRepositoryEntry, true);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         JobRepositoryRestore job = backup.getLastRepositoryRestore(repositoryNameToRestore);
+      backup.restore(bchLog, newRE, true);
+      waitEndOfRestore(newRE.getName());
 
-         while (job.getStateRestore() != JobRepositoryRestore.REPOSITORY_RESTORE_SUCCESSFUL
-                  || job.getStateRestore() == JobRepositoryRestore.REPOSITORY_RESTORE_FAIL)
-         {
-            Thread.yield();
-            Thread.sleep(50);
-         }
-
-         // check
-         ManageableRepository restoredRepository = repositoryService.getRepository(repositoryNameToRestore);
-
-         for (String wsName : restoredRepository.getWorkspaceNames())
-         {
-            SessionImpl back1 = null;
-            try
-            {
-               back1 = (SessionImpl) restoredRepository.login(credentials, wsName);
-               Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-               assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                        .getProperty("exo:data").getString());
-            }
-            catch (Exception e)
-            {
-               e.printStackTrace();
-               fail(e.getMessage());
-            }
-            finally
-            {
-               if (back1 != null)
-                  back1.logout();
-            }
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      checkConent(repositoryService.getRepository(newRE.getName()), newRE.getSystemWorkspaceName());
    }
 
    public void testRepositoryFullBackupAsynchronusRestoreWorkspaceMapping() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
-
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
       backup.stopBackup(bch);
 
       // restore
-      RepositoryEntry newRepositoryEntry =
-               makeRepositoryEntry(repositoryNameToRestore, getReposityToBackup().getConfiguration(),
-                        dataSourceToRepositoryRestore, null);
+      RepositoryEntry newRE = helper.createRepositoryEntry(true, null, null);
 
       // create workspace mappingS
       Map<String, String> workspaceMapping = new HashedMap();
-      for (WorkspaceEntry we : newRepositoryEntry.getWorkspaceEntries())
-      {
-         workspaceMapping.put(we.getName(), we.getName() + "_mapped");
-      }
+      workspaceMapping.put(repository.getConfiguration().getSystemWorkspaceName(), newRE.getSystemWorkspaceName());
 
-      // Change workspaeNames
-      for (WorkspaceEntry we : newRepositoryEntry.getWorkspaceEntries())
-      {
-         if (newRepositoryEntry.getSystemWorkspaceName().equals(we.getName()))
-         {
-            newRepositoryEntry.setSystemWorkspaceName(workspaceMapping.get(we.getName()));
-            newRepositoryEntry.setDefaultWorkspaceName(workspaceMapping.get(we.getName()));
-         }
-
-         we.setName(workspaceMapping.get(we.getName()));
-         we.setUniqueName(we.getUniqueName() + workspaceMapping.get(we.getName()));
-      }
-
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
-         backup.restore(bchLog, newRepositoryEntry, workspaceMapping, true);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         JobRepositoryRestore job = backup.getLastRepositoryRestore(repositoryNameToRestore);
+      backup.restore(bchLog, newRE, workspaceMapping, true);
+      waitEndOfRestore(newRE.getName());
 
-         while (job.getStateRestore() != JobRepositoryRestore.REPOSITORY_RESTORE_SUCCESSFUL
-                  || job.getStateRestore() == JobRepositoryRestore.REPOSITORY_RESTORE_FAIL)
-         {
-            Thread.yield();
-            Thread.sleep(50);
-         }
-
-         // check
-         ManageableRepository restoredRepository = repositoryService.getRepository(repositoryNameToRestore);
-
-         for (String wsName : restoredRepository.getWorkspaceNames())
-         {
-            SessionImpl back1 = null;
-            try
-            {
-               back1 = (SessionImpl) restoredRepository.login(credentials, workspaceMapping.get(wsName));
-               Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-               assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                        .getProperty("exo:data").getString());
-            }
-            catch (Exception e)
-            {
-               e.printStackTrace();
-               fail(e.getMessage());
-            }
-            finally
-            {
-               if (back1 != null)
-                  back1.logout();
-            }
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      checkConent(repositoryService.getRepository(newRE.getName()), newRE.getSystemWorkspaceName());
    }
 
-   public void testAutoStopRepositoryBackupIncrRepetion() throws Exception
+   public void _testAutoStopRepositoryBackupIncrRepetion() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_AND_INCREMENTAL);
-      config.setBackupDir(backDir);
       config.setIncrementalJobPeriod(4);
       config.setIncrementalJobNumber(2);
+      config.setBackupDir(backDir);
 
-      final RepositoryBackupChain bch = backup.startBackup(config);
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      while (!bch.isFinished())
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
+      // restore
+      RepositoryEntry newRE = helper.createRepositoryEntry(true, null, null);
 
-      Thread.sleep(5000);
+      // create workspace mappingS
+      Map<String, String> workspaceMapping = new HashedMap();
+      workspaceMapping.put(repository.getConfiguration().getSystemWorkspaceName(), newRE.getSystemWorkspaceName());
 
-      for (RepositoryBackupChain chain : backup.getCurrentRepositoryBackups())
-         if (bch.getBackupId().equals(chain.getBackupId()))
-            fail("The backup with id '" + chain.getBackupId() + "' should not be active");
+      File backLog = new File(bch.getLogFilePath());
+      assertTrue(backLog.exists());
+
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
+
+      backup.restore(bchLog, newRE, workspaceMapping, true);
+      waitEndOfRestore(newRE.getName());
+
+      Thread.sleep(60000);
+      assertEquals(backup.getCurrentRepositoryBackups().size(), 0);
    }
 
    public void testRepositoryRestoreFail() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
-
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
       backup.stopBackup(bch);
 
-      Thread.sleep(5000);
-
-      String repoName = repositoryNameToRestore + System.currentTimeMillis();
-
       // restore
-      RepositoryEntry newRepositoryEntry =
-               makeRepositoryEntry(repoName, getReposityToBackup().getConfiguration(), dataSourceToRepositoryRestore,
-                        null);
+      RepositoryEntry newRE = helper.createRepositoryEntry(true, null, null);
+      newRE.getWorkspaceEntries().get(0).getQueryHandler().setType("gg");
 
-      //create broken system workspaceEntry
-      newRepositoryEntry.getWorkspaceEntries().get(0).getQueryHandler().setType("gg");
+      // create workspace mappingS
+      Map<String, String> workspaceMapping = new HashedMap();
+      workspaceMapping.put(repository.getConfiguration().getSystemWorkspaceName(), newRE.getSystemWorkspaceName());
 
-      File backLog = new File(backup.getRepositoryBackupsLogs()[0].getLogFilePath());
+      File backLog = new File(bch.getLogFilePath());
+      assertTrue(backLog.exists());
 
       RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
+
       try
       {
-         backup.restore(bchLog, newRepositoryEntry, false);
-         fail("The backup " + backLog.getAbsolutePath() + "shoulde not restored.");
+         backup.restore(bchLog, newRE, workspaceMapping, false);
+         fail("Exception should be thrown");
       }
       catch (RepositoryRestoreExeption e)
       {
-         // ok.  
       }
-
-      // check
-      try
-      {
-         ManageableRepository restoredRepository = repositoryService.getRepository(repoName);
-         fail("The repository " + repositoryNameToRestore + "shoulde not exists.");
-      }
-      catch (RepositoryException e)
-      {
-         // ok.
-      }
    }
 
-   public void testIncrementalBackupRestoreEXOJCR_737() throws Exception
+   public void testExistedWorkspaceRestoreMultiDB() throws Exception
    {
-      // full backup with BLOBs & incremental with BLOBs
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+      addConent(repository, wsEntry.getName());
 
-      // BLOBs for full
-      File tempf = createBLOBTempFile("testIncrementalBackupRestore737-", 5 * 1024); // 5M
-      tempf.deleteOnExit();
-
-      File backDir = new File("target/backup/" + getUUIndex());
+      // backup
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
-      config.setBackupType(BackupManager.FULL_AND_INCREMENTAL);
-
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
+      config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
+      // restore
+      File backLog = new File(bch.getLogFilePath());
+      assertTrue(backLog.exists());
 
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-      // add data
-      ws1Session.getRootNode().addNode("node_101").setProperty("exo:data", new FileInputStream(tempf));
-      ws1Session.getRootNode().addNode("node_102").setProperty("exo:extraData", new FileInputStream(tempf));
-      ws1Session.getRootNode().save(); // log here via listener
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-      // stop backup
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
+      backup.restoreExistingWorkspace(bchLog, repository.getConfiguration().getName(), repository.getConfiguration()
+         .getWorkspaceEntries().get(1), false);
+      checkConent(repository, repository.getConfiguration().getWorkspaceEntries().get(1).getName());
+   }
 
-      //remove data 
-      ws1Session.getRootNode().getNode("node_101").remove();
-      ws1Session.getRootNode().getNode("node_102").remove();
-      ws1Session.getRootNode().save();
+   public void testExistedWorkspaceRestoreSingleDB() throws Exception
+   {
+      // prepare
+      String dsName = helper.createDatasource();
 
-      // restore
-      WorkspaceEntry ws1back = makeWorkspaceEntry(workspaceNameToRestore, dataSourceToWorkspaceRestore);
+      ManageableRepository repository = helper.createRepository(container, false, dsName);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(false, dsName);
+      helper.addWorkspace(repository, wsEntry);
+      addConent(repository, wsEntry.getName());
 
-      File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
+      // backup
+      File backDir = new File("target/backup/" + IdGenerator.generate());
+      backDir.mkdirs();
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      BackupConfig config = new BackupConfig();
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
+      config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
+      config.setBackupDir(backDir);
 
-         backup.restore(bchLog, repositoryNameToBackup, ws1back, false);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 = (SessionImpl) getReposityToBackup().login(credentials, workspaceNameToRestore);
+      // restore
+      File backLog = new File(bch.getLogFilePath());
+      assertTrue(backLog.exists());
 
-            Node node_101 = back1.getRootNode().getNode("node_101");
-            assertNotNull(node_101);
-            assertEquals(tempf.length(), node_101.getProperty("exo:data").getStream().available());
-            compareStream(new FileInputStream(tempf), node_101.getProperty("exo:data").getStream());
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-            Node node_102 = back1.getRootNode().getNode("node_102");
-            assertNotNull(node_102);
-            assertEquals(tempf.length(), node_102.getProperty("exo:extraData").getStream().available());
-            compareStream(new FileInputStream(tempf), node_102.getProperty("exo:extraData").getStream());
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restoreExistingWorkspace(bchLog, repository.getConfiguration().getName(), repository.getConfiguration()
+         .getWorkspaceEntries().get(1), false);
+      checkConent(repository, repository.getConfiguration().getWorkspaceEntries().get(1).getName());
    }
 
-   public void testExistedWorkspaceRestoreMultiDB() throws Exception
+   public void testExistedWorkspaceRestoreAsync() throws Exception
    {
-      String repositoryNameToBackup = "db8";
-      SessionImpl ws1Session =
-         (SessionImpl)repositoryService.getRepository(repositoryNameToBackup).login(credentials, "ws1");
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+      addConent(repository, wsEntry.getName());
 
-      ws1Session.getRootNode().addNode("TESTNODE");
-      ws1Session.save();
-
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
-
       // restore
-      RepositoryEntry re =
-               (RepositoryEntry) ws1Session.getContainer().getComponentInstanceOfType(RepositoryEntry.class);
-      WorkspaceEntry ws1 = null;
-      for (WorkspaceEntry we : re.getWorkspaceEntries())
-      {
-         if (ws1Session.getWorkspace().getName().equals(we.getName()))
-         {
-            ws1 = we;
-            break;
-         }
-      }
-
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-         backup.restoreExistingWorkspace(bchLog, repositoryNameToBackup, ws1, false);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 = (SessionImpl)repositoryService.getRepository("db8").login(credentials, "ws1");
-            Node ws1backTestRoot = back1.getRootNode().getNode("TESTNODE");
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
+      backup.restoreExistingWorkspace(bchLog, repository.getConfiguration().getName(), repository.getConfiguration()
+         .getWorkspaceEntries().get(1), true);
+      waitEndOfRestore(repository.getConfiguration().getName(), repository.getConfiguration().getWorkspaceEntries()
+         .get(1).getName());
 
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      assertEquals(
+         backup.getLastRestore(repository.getConfiguration().getName(),
+            repository.getConfiguration().getWorkspaceEntries().get(1).getName()).getStateRestore(),
+         JobWorkspaceRestore.RESTORE_SUCCESSFUL);
+
+      checkConent(repository, repository.getConfiguration().getWorkspaceEntries().get(1).getName());
    }
 
-   public void testExistedWorkspaceRestore() throws Exception
+   public void testExistedRepositoryRestoreMultiDB() throws Exception
    {
-      SessionImpl ws1Session = (SessionImpl) repositoryService.getRepository("db7").login(credentials, "ws1");
+      // prepare
+      String dsName = helper.createDatasource();
+      ManageableRepository repository = helper.createRepository(container, true, dsName);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
 
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
-      BackupConfig config = new BackupConfig();
-      config.setRepository("db7");
-      config.setWorkspace(workspaceNameToBackup);
+      RepositoryBackupConfig config = new RepositoryBackupConfig();
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      BackupChain bch = backup.findBackup("db7", workspaceNameToBackup);
 
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
+      File backLog = new File(bch.getLogFilePath());
+      assertTrue(backLog.exists());
 
-      // stop fullBackup
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
       // restore
-      RepositoryEntry re =
-               (RepositoryEntry) ws1Session.getContainer().getComponentInstanceOfType(RepositoryEntry.class);
-      WorkspaceEntry ws1 = null;
-      for (WorkspaceEntry we : re.getWorkspaceEntries())
-      {
-         if (ws1Session.getWorkspace().getName().equals(we.getName()))
-         {
-            ws1 = we;
-            break;
-         }
-      }
+      RepositoryEntry newRE =
+         helper.createRepositoryEntry(true, repository.getConfiguration().getSystemWorkspaceName(), dsName);
+      newRE.setName(repository.getConfiguration().getName());
 
+      backup.restoreExistingRepository(bchLog, newRE, false);
+      checkConent(repositoryService.getRepository(newRE.getName()), newRE.getSystemWorkspaceName());
+   }
+
+   public void testExistedRepositoryRestoreSingelDB() throws Exception
+   {
+      // prepare
+      String dsName = helper.createDatasource();
+      ManageableRepository repository = helper.createRepository(container, false, dsName);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
+      // backup
+      File backDir = new File("target/backup/" + IdGenerator.generate());
+      backDir.mkdirs();
+
+      RepositoryBackupConfig config = new RepositoryBackupConfig();
+      config.setRepository(repository.getConfiguration().getName());
+      config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
+      config.setBackupDir(backDir);
+
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
+
+
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
-         backup.restoreExistingWorkspace(bchLog, "db7", ws1, false);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 = (SessionImpl) repositoryService.getRepository("db7").login(credentials, "ws1");
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-            assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                     .getProperty("exo:data").getString());
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      // restore
+      RepositoryEntry newRE =
+         helper.createRepositoryEntry(false, repository.getConfiguration().getSystemWorkspaceName(), dsName);
+      newRE.setName(repository.getConfiguration().getName());
+
+      backup.restoreExistingRepository(bchLog, newRE, false);
+      checkConent(repositoryService.getRepository(newRE.getName()), newRE.getSystemWorkspaceName());
    }
 
-   public void testExistedWorkspaceRestoreAsync() throws Exception
+   public void testExistedRepositoryRestoreAsync() throws Exception
    {
+      // prepare
+      String dsName = helper.createDatasource();
+      ManageableRepository repository = helper.createRepository(container, false, dsName);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
-      BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      RepositoryBackupConfig config = new RepositoryBackupConfig();
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
+      File backLog = new File(bch.getLogFilePath());
+      assertTrue(backLog.exists());
 
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
-      // stop fullBackup
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
-
       // restore
-      RepositoryEntry re =
-               (RepositoryEntry) ws1Session.getContainer().getComponentInstanceOfType(RepositoryEntry.class);
-      WorkspaceEntry ws1 = null;
-      for (WorkspaceEntry we : re.getWorkspaceEntries())
-      {
-         if (ws1Session.getWorkspace().getName().equals(we.getName()))
-         {
-            ws1 = we;
-            break;
-         }
-      }
+      RepositoryEntry newRE =
+         helper.createRepositoryEntry(false, repository.getConfiguration().getSystemWorkspaceName(), dsName);
+      newRE.setName(repository.getConfiguration().getName());
 
-      File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
+      backup.restoreExistingRepository(bchLog, newRE, true);
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      waitEndOfRestore(repository.getConfiguration().getName());
 
-         backup.restoreExistingWorkspace(bchLog, repositoryNameToBackup, ws1, true);
+      assertEquals(JobRepositoryRestore.REPOSITORY_RESTORE_SUCCESSFUL,
+         backup.getLastRepositoryRestore(repository.getConfiguration().getName()).getStateRestore());
 
-         while (backup.getLastRestore(repositoryNameToBackup, ws1.getName()).getStateRestore() != JobWorkspaceRestore.RESTORE_SUCCESSFUL
-                  && backup.getLastRestore(repositoryNameToBackup, ws1.getName()).getStateRestore() != JobWorkspaceRestore.RESTORE_FAIL)
-         {
-            Thread.sleep(50);
-         }
-
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 =
-                     (SessionImpl) repositoryService.getRepository(repositoryNameToBackup).login(credentials,
-                              workspaceNameToBackup);
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-            assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                     .getProperty("exo:data").getString());
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      checkConent(repositoryService.getRepository(newRE.getName()), newRE.getSystemWorkspaceName());
    }
 
-   public void testExistedWorkspaceRestoreAsync2() throws Exception
+
+   public void testExistedWorkspaceRestoreWithConfig() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+      addConent(repository, wsEntry.getName());
 
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
-
       // restore
-      RepositoryEntry re =
-               (RepositoryEntry) ws1Session.getContainer().getComponentInstanceOfType(RepositoryEntry.class);
-      WorkspaceEntry ws1 = null;
-      for (WorkspaceEntry we : re.getWorkspaceEntries())
-      {
-         if (ws1Session.getWorkspace().getName().equals(we.getName()))
-         {
-            ws1 = we;
-            break;
-         }
-      }
-
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-         backup.restoreExistingWorkspace(bchLog.getBackupId(), repositoryNameToBackup, ws1, true);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         while (backup.getLastRestore(repositoryNameToBackup, ws1.getName()).getStateRestore() != JobWorkspaceRestore.RESTORE_SUCCESSFUL
-                  && backup.getLastRestore(repositoryNameToBackup, ws1.getName()).getStateRestore() != JobWorkspaceRestore.RESTORE_FAIL)
-         {
-            Thread.sleep(50);
-         }
-
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 =
-                     (SessionImpl) repositoryService.getRepository(repositoryNameToBackup).login(credentials,
-                              workspaceNameToBackup);
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-            assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                     .getProperty("exo:data").getString());
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restoreExistingWorkspace(bchLog.getBackupId(), false);
+      checkConent(repository, repository.getConfiguration().getWorkspaceEntries().get(1).getName());
    }
 
-   public void testExistedRepositoryRestore() throws Exception
+   public void testExistedRepositoryRestoreWithConfig() throws Exception
    {
+      // prepare
+      String dsName = helper.createDatasource();
+      ManageableRepository repository = helper.createRepository(container, true, dsName);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
-
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
       backup.stopBackup(bch);
 
-      // restore             
-      RepositoryEntry re =
-               makeRepositoryEntry(repositoryNameToBackup, getReposityToBackup().getConfiguration(), null, null);
-
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
-         backup.restoreExistingRepository(bchLog, re, false);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         assertEquals(JobWorkspaceRestore.RESTORE_SUCCESSFUL, backup.getLastRepositoryRestore(repositoryNameToBackup)
-                  .getStateRestore());
+      // restore
+      RepositoryEntry newRE =
+         helper.createRepositoryEntry(true, repository.getConfiguration().getSystemWorkspaceName(), dsName);
+      newRE.setName(repository.getConfiguration().getName());
 
-         // check
-         ManageableRepository restoredRepository = repositoryService.getRepository(repositoryNameToBackup);
-
-         for (String wsName : restoredRepository.getWorkspaceNames())
-         {
-            SessionImpl back1 = null;
-            try
-            {
-               back1 = (SessionImpl) restoredRepository.login(credentials, wsName);
-               Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-               assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                        .getProperty("exo:data").getString());
-            }
-            catch (Exception e)
-            {
-               e.printStackTrace();
-               fail(e.getMessage());
-            }
-            finally
-            {
-               if (back1 != null)
-                  back1.logout();
-            }
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restoreExistingRepository(bchLog.getBackupId(), false);
+      checkConent(repositoryService.getRepository(newRE.getName()), newRE.getSystemWorkspaceName());
    }
 
-   public void testExistedRepositoryRestoreSingelDB() throws Exception
+   public void testWorkspaceRestoreWithConfig() throws Exception
    {
-      RepositoryImpl repositoryDB7 = (RepositoryImpl) repositoryService.getRepository(repositoryNameToBackupSingleDB);
-      SessionImpl sessionWS = (SessionImpl) repositoryDB7.login(credentials, workspaceNameToBackup);
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+      addConent(repository, wsEntry.getName());
 
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
-      RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackupSingleDB);
+      BackupConfig config = new BackupConfig();
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
-
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackupSingleDB);
-
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
       backup.stopBackup(bch);
 
-      // restore             
-      RepositoryEntry baseRE =
-               (RepositoryEntry) sessionWS.getContainer().getComponentInstanceOfType(RepositoryEntry.class);
-      RepositoryEntry re = makeRepositoryEntry(baseRE.getName(), baseRE, null, null);
+      removeWorkspaceFully(repository.getConfiguration().getName(), wsEntry.getName());
 
+      // restore
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-         backup.restoreExistingRepository(bchLog, re, false);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         assertEquals(JobWorkspaceRestore.RESTORE_SUCCESSFUL, backup.getLastRepositoryRestore(re.getName())
-                  .getStateRestore());
-
-         // check
-         ManageableRepository restoredRepository = repositoryService.getRepository(repositoryNameToBackupSingleDB);
-
-         for (String wsName : restoredRepository.getWorkspaceNames())
-         {
-            SessionImpl back1 = null;
-            try
-            {
-               back1 = (SessionImpl) restoredRepository.login(credentials, wsName);
-               Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-               assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                        .getProperty("exo:data").getString());
-            }
-            catch (Exception e)
-            {
-               e.printStackTrace();
-               fail(e.getMessage());
-            }
-            finally
-            {
-               if (back1 != null)
-                  back1.logout();
-            }
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restoreWorkspace(bchLog.getBackupId(), false);
+      checkConent(repository, repository.getConfiguration().getWorkspaceEntries().get(1).getName());
    }
 
-   public void testExistedRepositoryRestoreAsync() throws Exception
+   public void testRepositoryRestoreWithConfig() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
-
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
       backup.stopBackup(bch);
 
       // restore
-      RepositoryEntry re =
-               makeRepositoryEntry(repositoryNameToBackup, getReposityToBackup().getConfiguration(), null, null);
+      removeRepositoryFully(repository.getConfiguration().getName());
 
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
-         backup.restoreExistingRepository(bchLog, re, true);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         JobRepositoryRestore job = backup.getLastRepositoryRestore(repositoryNameToBackup);
+      backup.restoreRepository(bchLog.getBackupId(), false);
 
-         while (job.getStateRestore() != JobRepositoryRestore.REPOSITORY_RESTORE_SUCCESSFUL
-                  && job.getStateRestore() != JobRepositoryRestore.REPOSITORY_RESTORE_FAIL)
-         {
-            Thread.sleep(50);
-         }
-
-         assertEquals(JobRepositoryRestore.REPOSITORY_RESTORE_SUCCESSFUL, backup.getLastRepositoryRestore(
-                  repositoryNameToBackup).getStateRestore());
-
-         // check
-         ManageableRepository restoredRepository = repositoryService.getRepository(repositoryNameToBackup);
-
-         for (String wsName : restoredRepository.getWorkspaceNames())
-         {
-            SessionImpl back1 = null;
-            try
-            {
-               back1 = (SessionImpl) restoredRepository.login(credentials, wsName);
-               Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-               assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                        .getProperty("exo:data").getString());
-            }
-            catch (Exception e)
-            {
-               e.printStackTrace();
-               fail(e.getMessage());
-            }
-            finally
-            {
-               if (back1 != null)
-                  back1.logout();
-            }
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      checkConent(repositoryService.getRepository(config.getRepository()),
+         repositoryService.getRepository(config.getRepository()).getConfiguration().getSystemWorkspaceName());
    }
 
-   public void testExistedRepositoryRestoreAsync2() throws Exception
+   public void testRepositoryRestoreWithNullConfig() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
       // backup
-      File backDir = new File("target/backup");
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
-
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
       backup.stopBackup(bch);
 
       // restore
-      RepositoryEntry re =
-               makeRepositoryEntry(repositoryNameToBackup, getReposityToBackup().getConfiguration(), null, null);
+      removeRepositoryFully(repository.getConfiguration().getName());
 
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
-         backup.restoreExistingRepository(bchLog.getBackupId(), re, true);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         JobRepositoryRestore job = backup.getLastRepositoryRestore(repositoryNameToBackup);
-
-         while (job.getStateRestore() != JobRepositoryRestore.REPOSITORY_RESTORE_SUCCESSFUL
-                  && job.getStateRestore() != JobRepositoryRestore.REPOSITORY_RESTORE_FAIL)
-         {
-            Thread.sleep(50);
-         }
-
-         assertEquals(JobWorkspaceRestore.RESTORE_SUCCESSFUL, backup.getLastRepositoryRestore(repositoryNameToBackup)
-                  .getStateRestore());
-
-         // check
-         ManageableRepository restoredRepository = repositoryService.getRepository(repositoryNameToBackup);
-
-         for (String wsName : restoredRepository.getWorkspaceNames())
-         {
-            SessionImpl back1 = null;
-            try
-            {
-               back1 = (SessionImpl) restoredRepository.login(credentials, wsName);
-               Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-               assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                        .getProperty("exo:data").getString());
-            }
-            catch (Exception e)
-            {
-               e.printStackTrace();
-               fail(e.getMessage());
-            }
-            finally
-            {
-               if (back1 != null)
-                  back1.logout();
-            }
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restore(bchLog, null, false);
+      checkConent(repositoryService.getRepository(config.getRepository()),
+         repositoryService.getRepository(config.getRepository()).getConfiguration().getSystemWorkspaceName());
    }
 
-   public void testExistedWorkspaceRestoreSingelDB() throws Exception
+   public void testWorkspaceRestoreWithNullConfig() throws Exception
    {
-      RepositoryImpl repositoryDB7 = (RepositoryImpl) repositoryService.getRepository(repositoryNameToBackupSingleDB);
-      SessionImpl sessionWS = (SessionImpl) repositoryDB7.login(credentials, workspaceNameToBackup);
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+      addConent(repository, wsEntry.getName());
 
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackupSingleDB);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      BackupChain bch = backup.findBackup(repositoryNameToBackupSingleDB, workspaceNameToBackup);
+      removeWorkspaceFully(repository.getConfiguration().getName(), wsEntry.getName());
 
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
+      // restore
+      File backLog = new File(bch.getLogFilePath());
+      assertTrue(backLog.exists());
 
-      // stop fullBackup
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-      // restore
-      RepositoryEntry re = (RepositoryEntry) sessionWS.getContainer().getComponentInstanceOfType(RepositoryEntry.class);
-      WorkspaceEntry ws1 = null;
-      for (WorkspaceEntry we : re.getWorkspaceEntries())
+      try
       {
-         if (sessionWS.getWorkspace().getName().equals(we.getName()))
-         {
-            ws1 = we;
-            break;
-         }
+         backup.restore(bchLog, repository.getConfiguration().getName() + "not_exists", null, false);
+         fail("Exception should be thrown");
       }
-
-      File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
+      catch (Exception e)
       {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
-
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
-
-         backup.restoreExistingWorkspace(bchLog, repositoryNameToBackupSingleDB, ws1, false);
-
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            repositoryDB7 = (RepositoryImpl) repositoryService.getRepository(repositoryNameToBackupSingleDB);
-            back1 = (SessionImpl) repositoryDB7.login(credentials, workspaceNameToBackup);
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-            assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                     .getProperty("exo:data").getString());
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
       }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+
+      backup.restore(bchLog, repository.getConfiguration().getName(), null, false);
+      checkConent(repository, repository.getConfiguration().getWorkspaceEntries().get(1).getName());
    }
 
-   public void testExistedWorkspaceRestoreWithConfig() throws Exception
+   public void testExistedWorkspaceRestoreWithConfigBackupSetDir() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+      addConent(repository, wsEntry.getName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
-
-      super.tearDown();
-
+      // restore
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-         backup.restoreExistingWorkspace(bchLog.getBackupId(), false);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 =
-                     (SessionImpl) repositoryService.getRepository(repositoryNameToBackup).login(credentials,
-                              workspaceNameToBackup);
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-            assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                     .getProperty("exo:data").getString());
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restoreExistingWorkspace(bchLog.getBackupConfig().getBackupDir(), false);
+      checkConent(repository, repository.getConfiguration().getWorkspaceEntries().get(1).getName());
    }
 
-   public void testExistedRepositoryRestoreWithConfig() throws Exception
+   public void testExistedRepositoryRestoreWithConfigBackupSetDir() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
-
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
       backup.stopBackup(bch);
 
-      // check
-      super.tearDown();
-
-      // restore             
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
-         backup.restoreExistingRepository(bchLog.getBackupId(), false);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         assertEquals(JobWorkspaceRestore.RESTORE_SUCCESSFUL, backup.getLastRepositoryRestore(repositoryNameToBackup)
-                  .getStateRestore());
-
-         // check
-         ManageableRepository restoredRepository = repositoryService.getRepository(repositoryNameToBackup);
-
-         for (String wsName : restoredRepository.getWorkspaceNames())
-         {
-            SessionImpl back1 = null;
-            try
-            {
-               back1 = (SessionImpl) restoredRepository.login(credentials, wsName);
-               Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-               assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                        .getProperty("exo:data").getString());
-            }
-            catch (Exception e)
-            {
-               e.printStackTrace();
-               fail(e.getMessage());
-            }
-            finally
-            {
-               if (back1 != null)
-                  back1.logout();
-            }
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restoreExistingRepository(bchLog.getBackupConfig().getBackupDir(), false);
+      checkConent(repositoryService.getRepository(config.getRepository()),
+         repositoryService.getRepository(config.getRepository()).getConfiguration().getSystemWorkspaceName());
    }
 
-   public void testWorkspaceRestoreWithConfig() throws Exception
+   public void testWorkspaceRestoreWithConfigBackupSetDir() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      WorkspaceEntry wsEntry = helper.createWorkspaceEntry(true, null);
+      helper.addWorkspace(repository, wsEntry);
+      addConent(repository, wsEntry.getName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry.getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
+      removeWorkspaceFully(repository.getConfiguration().getName(), wsEntry.getName());
 
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
-
-      //TODO
-      //      super.tearDown();
-      removeWorkspaceFullySingleDB(repositoryNameToBackup, workspaceNameToBackup);
-
+      // restore
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-         backup.restoreWorkspace(bchLog.getBackupId(), false);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 = (SessionImpl) repositoryService.getRepository(repositoryNameToBackup).login(credentials, "ws1");
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-            assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                     .getProperty("exo:data").getString());
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restoreWorkspace(bchLog.getBackupConfig().getBackupDir(), false);
+      checkConent(repository, repository.getConfiguration().getWorkspaceEntries().get(1).getName());
    }
 
-   public void testRepositoryRestoreWithConfig() throws Exception
+   public void testRepositoryRestoreWithConfigBackupSetDir() throws Exception
    {
+      // prepare
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
-
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
-
-      // stop fullBackup
-
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
       backup.stopBackup(bch);
 
-      //TODO
-      super.tearDown();
-      removeRepositoryFully(repositoryNameToBackup);
+      // restore
+      removeRepositoryFully(repository.getConfiguration().getName());
 
-      // restore             
       File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+      assertTrue(backLog.exists());
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
-         backup.restoreRepository(bchLog.getBackupId(), false);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-         assertEquals(JobWorkspaceRestore.RESTORE_SUCCESSFUL, backup.getLastRepositoryRestore(repositoryNameToBackup)
-                  .getStateRestore());
-
-         // check
-         ManageableRepository restoredRepository = repositoryService.getRepository(repositoryNameToBackup);
-
-         for (String wsName : restoredRepository.getWorkspaceNames())
-         {
-            SessionImpl back1 = null;
-            try
-            {
-               back1 = (SessionImpl) restoredRepository.login(credentials, wsName);
-               Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-               assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                        .getProperty("exo:data").getString());
-            }
-            catch (Exception e)
-            {
-               e.printStackTrace();
-               fail(e.getMessage());
-            }
-            finally
-            {
-               if (back1 != null)
-                  back1.logout();
-            }
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restoreRepository(bchLog.getBackupConfig().getBackupDir(), false);
+      checkConent(repositoryService.getRepository(config.getRepository()),
+         repositoryService.getRepository(config.getRepository()).getConfiguration().getSystemWorkspaceName());
    }
 
-   public void testRepositoryRestoreWithNullConfig() throws Exception
+   public void testRelativeBackupDir() throws Exception
    {
+      // prepare stage #1
+      ManageableRepository repository = helper.createRepository(container, true, null);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
       // backup
-      File backDir = new File((File.createTempFile("12123", "123")).getParent() + File.separator + getUUIndex());
-      backDir.mkdirs();
+      File backDir = new File("target");
 
       RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackup);
+      // prepare stage #2
+      String repositoryBackupChainLogPath = bch.getLogFilePath();
 
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FINISHED)
+      String relativePrefixBackupDir = backDir.getCanonicalFile().getParent() + File.separator;
+
+      String newBackupDir =
+         bch.getBackupConfig().getBackupDir().getCanonicalPath().replace(relativePrefixBackupDir, "");
+      String newBackupDirForWrite = newBackupDir;
+      if (File.separator.equals("\\"))
       {
-         Thread.yield();
-         Thread.sleep(50);
+         newBackupDirForWrite = newBackupDir.replaceAll("\\\\", "\\\\\\\\");
       }
 
-      // stop fullBackup
+      File dest = new File(repositoryBackupChainLogPath + ".xml");
+      dest.createNewFile();
 
-      backup.stopBackup(bch);
+      RepositoryBackupChainLog newRepositoryBackupChainLog = null;
 
-      //TODO
-      super.tearDown();
-      removeRepositoryFully(repositoryNameToBackup);
+      String sConfig =
+         setNewBackupDirInRepositoryBackupChainLog(new File(repositoryBackupChainLogPath), dest, newBackupDirForWrite);
 
-      // restore             
-      File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+      assertTrue(sConfig.contains(newBackupDir));
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      // check
+      newRepositoryBackupChainLog = new RepositoryBackupChainLog(dest);
 
-         backup.restore(bchLog, null, false);
+      assertEquals(bch.getBackupConfig().getBackupDir().getCanonicalPath(), newRepositoryBackupChainLog
+         .getBackupConfig().getBackupDir().getCanonicalPath());
+   }
 
-         assertEquals(JobWorkspaceRestore.RESTORE_SUCCESSFUL, backup.getLastRepositoryRestore(repositoryNameToBackup)
-                  .getStateRestore());
+   /**
+     * Use JobExistingWorkspaceSameConfigRestore to restore.
+     */
 
-         // check
-         ManageableRepository restoredRepository = repositoryService.getRepository(repositoryNameToBackup);
+   public void testExistedWorkspaceRestoreSingleDBTwoWS() throws Exception
+   {
+      // prepare
+      String dsName1 = helper.createDatasource();
+      String dsName2 = helper.createDatasource();
 
-         for (String wsName : restoredRepository.getWorkspaceNames())
-         {
-            SessionImpl back1 = null;
-            try
-            {
-               back1 = (SessionImpl) restoredRepository.login(credentials, wsName);
-               Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-               assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                        .getProperty("exo:data").getString());
-            }
-            catch (Exception e)
-            {
-               e.printStackTrace();
-               fail(e.getMessage());
-            }
-            finally
-            {
-               if (back1 != null)
-                  back1.logout();
-            }
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
-   }
+      ManageableRepository repository = helper.createRepository(container, false, dsName1);
+      WorkspaceEntry wsEntry1 = helper.createWorkspaceEntry(false, dsName1);
+      helper.addWorkspace(repository, wsEntry1);
+      addConent(repository, wsEntry1.getName());
 
-   public void testWorkspaceRestoreWithNullConfig() throws Exception
-   {
+      WorkspaceEntry wsEntry2 = helper.createWorkspaceEntry(false, dsName2);
+      helper.addWorkspace(repository, wsEntry2);
+      addConent(repository, wsEntry2.getName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry1.getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
+      // restore
+      File backLog = new File(bch.getLogFilePath());
+      assertTrue(backLog.exists());
 
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-      // stop fullBackup
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
+      backup.restoreExistingWorkspace(bchLog, repository.getConfiguration().getName(), repository.getConfiguration()
+         .getWorkspaceEntries().get(1), false);
+      checkConent(repository, repository.getConfiguration().getWorkspaceEntries().get(1).getName());
+      checkConent(repository, repository.getConfiguration().getWorkspaceEntries().get(2).getName());
+   }
 
-      //TODO
-      removeWorkspaceFullySingleDB(repositoryNameToBackup, workspaceNameToBackup);
+   /**
+     * Use JobExistingWorkspaceRestore to restore.
+     */
 
-      File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
+   public void testExistedWorkspaceRestoreSingleDBTwoWSWithDiffConfig() throws Exception
+   {
+      // prepare
+      String dsName1 = helper.createDatasource();
+      String dsName2 = helper.createDatasource();
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      ManageableRepository repository = helper.createRepository(container, false, dsName1);
+      WorkspaceEntry wsEntry1 = helper.createWorkspaceEntry(false, dsName1);
+      helper.addWorkspace(repository, wsEntry1);
+      addConent(repository, wsEntry1.getName());
 
-         try
-         {
-            backup.restore(bchLog, repositoryNameToBackup + "not_exists", null, false);
-            fail("Should be throw exception WorkspaceRestoreException");
-         }
-         catch (WorkspaceRestoreException e)
-         {
-            //ok
-         }
+      WorkspaceEntry wsEntry2 = helper.createWorkspaceEntry(false, dsName2);
+      helper.addWorkspace(repository, wsEntry2);
+      addConent(repository, wsEntry2.getName());
 
-         backup.restore(bchLog, repositoryNameToBackup, null, false);
-
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 = (SessionImpl) getReposityToBackup().login(credentials, workspaceNameToBackup);
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-            assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                     .getProperty("exo:data").getString());
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
-   }
-
-   public void testExistedWorkspaceRestoreWithConfigBackupSetDir() throws Exception
-   {
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
+      config.setWorkspace(wsEntry1.getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      BackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
+      // restore
+      File backLog = new File(bch.getLogFilePath());
+      assertTrue(backLog.exists());
 
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
+      BackupChainLog bchLog = new BackupChainLog(backLog);
 
-      // stop fullBackup
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-      super.tearDown();
+      // change  cofig
+      WorkspaceEntry wsEntry = helper.copyWorkspaceEntry(repository.getConfiguration().getWorkspaceEntries().get(1));
 
-      File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
+      List<SimpleParameterEntry> params = wsEntry.getContainer().getParameters();
+      params.set(2, new SimpleParameterEntry("max-buffer-size", "307200"));
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      wsEntry.getContainer().setParameters(params);
 
-         backup.restoreExistingWorkspace(bchLog.getBackupConfig().getBackupDir(), false);
-
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 = (SessionImpl) getReposityToBackup().login(credentials, workspaceNameToBackup);
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-            assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                     .getProperty("exo:data").getString());
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      backup.restoreExistingWorkspace(bchLog, repository.getConfiguration().getName(), wsEntry, false);
+      checkConent(repository, repository.getConfiguration().getWorkspaceEntries().get(1).getName());
+      checkConent(repository, repository.getConfiguration().getWorkspaceEntries().get(2).getName());
    }
 
-   public void testExistedRepositoryRestoreWithConfigBackupSetDir() throws Exception
+   public void testExistedRepositoryRestoreSingelDBSameConfig() throws Exception
    {
+      // prepare
+      String dsName = helper.createDatasource();
+      ManageableRepository repository = helper.createRepository(container, false, dsName);
+      addConent(repository, repository.getConfiguration().getSystemWorkspaceName());
+
+      WorkspaceEntry wsEntry1 = helper.createWorkspaceEntry(false, dsName);
+      helper.addWorkspace(repository, wsEntry1);
+      addConent(repository, wsEntry1.getName());
+
       // backup
-      File backDir = new File("target/backup/" + getUUIndex());
+      File backDir = new File("target/backup/" + IdGenerator.generate());
       backDir.mkdirs();
 
       RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
+      config.setRepository(repository.getConfiguration().getName());
       config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
       config.setBackupDir(backDir);
 
-      backup.startBackup(config);
+      RepositoryBackupChain bch = backup.startBackup(config);
+      waitEndOfBackup(bch);
+      backup.stopBackup(bch);
 
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackup);
+      File backLog = new File(bch.getLogFilePath());
+      assertTrue(backLog.exists());
 
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FINISHED)
-      {
-         Thread.yield();
-         Thread.sleep(50);
-      }
+      RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
 
-      // stop fullBackup
-      backup.stopBackup(bch);
+      assertNotNull(bchLog.getStartedTime());
+      assertNotNull(bchLog.getFinishedTime());
 
-      // check
-      super.tearDown();
+      // restore
+      long timeOfRestore = System.currentTimeMillis();
+      backup.restoreExistingRepository(bchLog, helper.copyRepositoryEntry(repository.getConfiguration()), false);
+      checkConent(repositoryService.getRepository(repository.getConfiguration().getName()), repository
+         .getConfiguration().getSystemWorkspaceName());
+   }
 
-      // restore             
-      File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
-      {
-         RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+   /**
+    * Set new backup directory in RepositoryBackupChainLog
+    * 
+    * @param src
+    *          source file of RepositoryBackupChainLog
+    * @param dest
+    *          destination file of RepositoryBackupChainLog
+    * @param newBackupDir
+    * @return  String
+    *            the content of file destination  
+    * @throws IOException 
+    */
+   protected String setNewBackupDirInRepositoryBackupChainLog(File src, File dest, String newBackupDir)
+      throws IOException
+   {
+      InputStream in = new FileInputStream(src);
+      OutputStream out = new FileOutputStream(dest);
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+      byte[] buf = new byte[(int)(src.length())];
+      in.read(buf);
 
-         backup.restoreExistingRepository(bchLog.getBackupConfig().getBackupDir(), false);
+      String sConfig = new String(buf, Constants.DEFAULT_ENCODING);
+      sConfig = sConfig.replaceAll("<backup-dir>.+</backup-dir>", "<backup-dir>" + newBackupDir + "</backup-dir>");
 
-         assertEquals(JobWorkspaceRestore.RESTORE_SUCCESSFUL, backup.getLastRepositoryRestore(repositoryNameToBackup)
-                  .getStateRestore());
+      out.write(sConfig.getBytes(Constants.DEFAULT_ENCODING));
 
-         // check
-         ManageableRepository restoredRepository = repositoryService.getRepository(repositoryNameToBackup);
+      in.close();
+      out.close();
 
-         for (String wsName : restoredRepository.getWorkspaceNames())
+      return sConfig;
+   }
+
+   protected void deleteFolder(File f)
+   {
+      if (f.isDirectory())
+      {
+         for (File file : f.listFiles())
          {
-            SessionImpl back1 = null;
-            try
-            {
-               back1 = (SessionImpl) restoredRepository.login(credentials, wsName);
-               Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-               assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                        .getProperty("exo:data").getString());
-            }
-            catch (Exception e)
-            {
-               e.printStackTrace();
-               fail(e.getMessage());
-            }
-            finally
-            {
-               if (back1 != null)
-                  back1.logout();
-            }
+            deleteFolder(file);
          }
+
+         f.delete();
       }
       else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      {
+         f.delete();
+      }
    }
 
-   public void testWorkspaceRestoreWithConfigBackupSetDir() throws Exception
+   public void addConent(ManageableRepository repository, String wsName) throws Exception
    {
-      // backup
-      File backDir = new File((File.createTempFile("12123", "123")).getParent() + File.separator + getUUIndex());
-      backDir.mkdirs();
+      SessionImpl session = (SessionImpl)repository.login(credentials, wsName);
+      Node rootNode = session.getRootNode().addNode("test");
 
-      BackupConfig config = new BackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setWorkspace(workspaceNameToBackup);
-      config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
+      // add some changes which will be logged in incremental log
+      rootNode.addNode("node1").setProperty("prop1", "value1");
+      rootNode.addNode("node2").setProperty("prop2", new FileInputStream(blob));
+      rootNode.addNode("node3").addMixin("mix:lockable");
+      session.save();
+   }
 
-      config.setBackupDir(backDir);
-
-      backup.startBackup(config);
-
-      BackupChain bch = backup.findBackup(repositoryNameToBackup, workspaceNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getFullBackupState() != BackupJob.FINISHED)
+   public void waitEndOfBackup(BackupChain bch) throws Exception
+   {
+      while (bch.getFullBackupState() != BackupChain.FINISHED)
       {
          Thread.yield();
          Thread.sleep(50);
       }
+   }
 
-      // stop fullBackup
-
-      if (bch != null)
-         backup.stopBackup(bch);
-      else
-         fail("Can't get fullBackup chain");
-
-      //TODO
-      removeWorkspaceFullySingleDB(repositoryNameToBackup, workspaceNameToBackup);
-
-      File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
+   public void waitEndOfBackup(RepositoryBackupChain bch) throws Exception
+   {
+      while (bch.getState() != RepositoryBackupChain.FINISHED
+         && bch.getState() != RepositoryBackupChain.FULL_BACKUP_FINISHED_INCREMENTAL_BACKUP_WORKING)
       {
-         BackupChainLog bchLog = new BackupChainLog(backLog);
-
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
-
-         backup.restoreWorkspace(bchLog.getBackupConfig().getBackupDir(), false);
-
-         // check
-         SessionImpl back1 = null;
-         try
-         {
-            back1 = (SessionImpl) getReposityToBackup().login(credentials, "ws1");
-            Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-            assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                     .getProperty("exo:data").getString());
-         }
-         catch (Exception e)
-         {
-            e.printStackTrace();
-            fail(e.getMessage());
-         }
-         finally
-         {
-            if (back1 != null)
-               back1.logout();
-         }
+         Thread.yield();
+         Thread.sleep(50);
       }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
    }
 
-   public void testRepositoryRestoreWithConfigBackupSetDir() throws Exception
+   public void waitEndOfRestore(String repositoryName) throws Exception
    {
-      // backup
-      File backDir = new File((File.createTempFile("12123", "123")).getParent() + File.separator + getUUIndex());
-      backDir.mkdirs();
+      while (backup.getLastRepositoryRestore(repositoryName).getStateRestore() != JobRepositoryRestore.REPOSITORY_RESTORE_SUCCESSFUL
+         && backup.getLastRepositoryRestore(repositoryName).getStateRestore() != JobRepositoryRestore.REPOSITORY_RESTORE_FAIL)
+      {
+         Thread.sleep(50);
+      }
+   }
 
-      RepositoryBackupConfig config = new RepositoryBackupConfig();
-      config.setRepository(repositoryNameToBackup);
-      config.setBackupType(BackupManager.FULL_BACKUP_ONLY);
-
-      config.setBackupDir(backDir);
-
-      backup.startBackup(config);
-
-      RepositoryBackupChain bch = backup.findRepositoryBackup(repositoryNameToBackup);
-
-      // wait till full backup will be stopped
-      while (bch.getState() != RepositoryBackupChain.FINISHED)
+   public void waitEndOfRestore(String repositoryName, String workspaceName) throws Exception
+   {
+      while (backup.getLastRestore(repositoryName, workspaceName).getStateRestore() != JobWorkspaceRestore.RESTORE_SUCCESSFUL
+         && backup.getLastRestore(repositoryName, workspaceName).getStateRestore() != JobWorkspaceRestore.RESTORE_FAIL)
       {
-         Thread.yield();
          Thread.sleep(50);
       }
+   }
 
-      // stop fullBackup
+   public void checkConent(ManageableRepository repository, String wsName) throws Exception
+   {
+      SessionImpl session = (SessionImpl)repository.login(credentials, wsName);
 
-      backup.stopBackup(bch);
+      Node rootNode = session.getRootNode().getNode("test");
+      assertEquals(rootNode.getNode("node1").getProperty("prop1").getString(), "value1");
 
-      //TODO
-      super.tearDown();
-      removeRepositoryFully(repositoryNameToBackup);
-
-      // restore             
-      File backLog = new File(bch.getLogFilePath());
-      if (backLog.exists())
+      InputStream in = rootNode.getNode("node2").getProperty("prop2").getStream();
+      try
       {
-         RepositoryBackupChainLog bchLog = new RepositoryBackupChainLog(backLog);
+         compareStream(new FileInputStream(blob), in);
+      }
+      finally
+      {
+         in.close();
+      }
+   }
 
-         assertNotNull(bchLog.getStartedTime());
-         assertNotNull(bchLog.getFinishedTime());
+   public void checkIncrementalConent(ManageableRepository repository, String wsName) throws Exception
+   {
+      SessionImpl session = (SessionImpl)repository.login(credentials, wsName);
 
-         backup.restoreRepository(bchLog.getBackupConfig().getBackupDir(), false);
+      Node rootNode = session.getRootNode().getNode("testIncremental");
+      assertEquals(rootNode.getNode("node1").getProperty("prop1").getString(), "value1");
 
-         assertEquals(JobWorkspaceRestore.RESTORE_SUCCESSFUL, backup.getLastRepositoryRestore(repositoryNameToBackup)
-                  .getStateRestore());
+      InputStream in = rootNode.getNode("node2").getProperty("prop2").getStream();
+      try
+      {
+         compareStream(new FileInputStream(blob), in);
+      }
+      finally
+      {
+         in.close();
+      }
+   }
 
-         // check
-         ManageableRepository restoredRepository = repositoryService.getRepository(repositoryNameToBackup);
+   public void addIncrementalConent(ManageableRepository repository, String wsName) throws Exception
+   {
+      SessionImpl session = (SessionImpl)repository.login(credentials, wsName);
+      Node rootNode = session.getRootNode().addNode("testIncremental");
 
-         for (String wsName : restoredRepository.getWorkspaceNames())
-         {
-            SessionImpl back1 = null;
-            try
-            {
-               back1 = (SessionImpl) restoredRepository.login(credentials, wsName);
-               Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
-               assertEquals("Restored content should be same", "property-5", ws1backTestRoot.getNode("node_5")
-                        .getProperty("exo:data").getString());
-            }
-            catch (Exception e)
-            {
-               e.printStackTrace();
-               fail(e.getMessage());
-            }
-            finally
-            {
-               if (back1 != null)
-                  back1.logout();
-            }
-         }
-      }
-      else
-         fail("There are no backup files in " + backDir.getAbsolutePath());
+      // add some changes which will be logged in incremental log
+      rootNode.addNode("node1").setProperty("prop1", "value1");
+      rootNode.addNode("node2").setProperty("prop2", new FileInputStream(blob));
+      rootNode.addNode("node3").addMixin("mix:lockable");
+      session.save();
    }
+
 }
Index: exo.jcr.component.ext/src/test/java/org/exoplatform/services/jcr/util/TesterConfigurationHelper.java
===================================================================
--- exo.jcr.component.ext/src/test/java/org/exoplatform/services/jcr/util/TesterConfigurationHelper.java	(revision 0)
+++ exo.jcr.component.ext/src/test/java/org/exoplatform/services/jcr/util/TesterConfigurationHelper.java	(revision 0)
@@ -0,0 +1,354 @@
+/*
+ * Copyright (C) 2009 eXo Platform SAS.
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * This software is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this software; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
+ */
+package org.exoplatform.services.jcr.util;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Properties;
+
+import javax.jcr.RepositoryException;
+import javax.naming.Context;
+import javax.naming.InitialContext;
+import javax.sql.DataSource;
+
+import org.apache.commons.dbcp.BasicDataSourceFactory;
+import org.exoplatform.container.ExoContainer;
+import org.exoplatform.services.jcr.RepositoryService;
+import org.exoplatform.services.jcr.config.CacheEntry;
+import org.exoplatform.services.jcr.config.ContainerEntry;
+import org.exoplatform.services.jcr.config.QueryHandlerEntry;
+import org.exoplatform.services.jcr.config.RepositoryConfigurationException;
+import org.exoplatform.services.jcr.config.RepositoryEntry;
+import org.exoplatform.services.jcr.config.SimpleParameterEntry;
+import org.exoplatform.services.jcr.config.ValueStorageEntry;
+import org.exoplatform.services.jcr.config.ValueStorageFilterEntry;
+import org.exoplatform.services.jcr.config.WorkspaceEntry;
+import org.exoplatform.services.jcr.core.ManageableRepository;
+import org.exoplatform.services.log.ExoLogger;
+import org.exoplatform.services.log.Log;
+
+/**
+ * Created by The eXo Platform SAS
+ * 
+ * @author <a href="mailto:Sergey.Kabashnyuk@gmail.com">Sergey Kabashnyuk</a>
+ * @version $Id: ConfigurationHelper.java 11907 2008-03-13 15:36:21Z ksm $
+ */
+public class TesterConfigurationHelper
+{
+   private static Log log = ExoLogger.getLogger("exo.jcr.component.core.ConfigurationHelper");
+
+   private static TesterConfigurationHelper instance;
+
+   private TesterConfigurationHelper()
+   {
+      System.setProperty(Context.INITIAL_CONTEXT_FACTORY, "org.exoplatform.services.naming.SimpleContextFactory");
+   }
+
+   /**
+    * Add new workspace to repository.
+    */
+   public void addWorkspace(ManageableRepository repository, WorkspaceEntry workspaceEntry)
+      throws RepositoryConfigurationException, RepositoryException
+   {
+      repository.configWorkspace(workspaceEntry);
+      repository.createWorkspace(workspaceEntry.getName());
+   }
+
+   /**
+    * Create new datasource. 
+    * 
+    * @return datasource name
+    */
+   public String createDatasource() throws Exception
+   {
+      String dsName = IdGenerator.generate();
+
+      Properties properties = new Properties();
+      properties.setProperty("driverClassName", "org.hsqldb.jdbcDriver");
+      properties.setProperty("url", "jdbc:hsqldb:file:target/temp/data/" + dsName);
+      properties.setProperty("username", "sa");
+      properties.setProperty("password", "");
+
+      DataSource ds = BasicDataSourceFactory.createDataSource(properties);
+
+      new InitialContext().bind(dsName, ds);
+
+      return dsName;
+
+   }
+
+   public ManageableRepository createRepository(ExoContainer container, boolean isMultiDb, String dsName)
+      throws Exception
+   {
+      RepositoryService service = (RepositoryService)container.getComponentInstanceOfType(RepositoryService.class);
+      RepositoryEntry repoEntry = createRepositoryEntry(isMultiDb, null, dsName);
+      service.createRepository(repoEntry);
+
+      return service.getRepository(repoEntry.getName());
+   }
+
+   /**
+   * Create workspace entry. 
+   */
+   public RepositoryEntry createRepositoryEntry(boolean isMultiDb, String systemWSName, String dsName) throws Exception
+   {
+      // create system workspace entry
+      List<String> ids = new ArrayList<String>();
+      ids.add("id");
+      WorkspaceEntry wsEntry = createWorkspaceEntry(isMultiDb, dsName, ids);
+
+      if (systemWSName != null)
+      {
+         wsEntry.setName(systemWSName);
+      }
+
+      RepositoryEntry repository = new RepositoryEntry();
+      repository.setSystemWorkspaceName(wsEntry.getName());
+      repository.setDefaultWorkspaceName(wsEntry.getName());
+      repository.setName("repo-" + IdGenerator.generate());
+      repository.setSessionTimeOut(3600000);
+      repository.setAuthenticationPolicy("org.exoplatform.services.jcr.impl.core.access.JAASAuthenticator");
+      repository.setSecurityDomain("exo-domain");
+      repository.addWorkspace(wsEntry);
+
+      return repository;
+   }
+
+   /**
+   * Create copy of workspace entry. 
+   */
+   public WorkspaceEntry copyWorkspaceEntry(WorkspaceEntry baseWorkspaceEntry) throws Exception
+   {
+      // container entry
+      ArrayList<SimpleParameterEntry> params = new ArrayList<SimpleParameterEntry>();
+      params.addAll(copyList(baseWorkspaceEntry.getContainer().getParameters()));
+      ContainerEntry containerEntry = new ContainerEntry(baseWorkspaceEntry.getContainer().getType(), params);
+      containerEntry.setParameters(params);
+
+      // value storage
+      ArrayList<ValueStorageEntry> list = new ArrayList<ValueStorageEntry>();
+
+      for (ValueStorageEntry baseValueStorageEntry : baseWorkspaceEntry.getContainer().getValueStorages())
+      {
+         ArrayList<ValueStorageFilterEntry> vsparams = new ArrayList<ValueStorageFilterEntry>();
+
+         for (ValueStorageFilterEntry baseValueStorageFilterEntry : baseValueStorageEntry.getFilters())
+         {
+            ValueStorageFilterEntry filterEntry = new ValueStorageFilterEntry();
+            filterEntry.setPropertyType(baseValueStorageFilterEntry.getPropertyType());
+            filterEntry.setPropertyName(baseValueStorageFilterEntry.getPropertyName());
+            filterEntry.setAncestorPath(baseValueStorageFilterEntry.getAncestorPath());
+            filterEntry.setMinValueSize(baseValueStorageFilterEntry.getMinValueSize());
+
+            vsparams.add(filterEntry);
+         }
+
+         ValueStorageEntry valueStorageEntry = new ValueStorageEntry(baseValueStorageEntry.getType(), vsparams);
+         ArrayList<SimpleParameterEntry> spe = new ArrayList<SimpleParameterEntry>();
+         spe.addAll(copyList(baseValueStorageEntry.getParameters()));
+         valueStorageEntry.setId(baseValueStorageEntry.getId());
+         valueStorageEntry.setParameters(spe);
+         valueStorageEntry.setFilters(vsparams);
+
+         // containerEntry.setValueStorages();
+         list.add(valueStorageEntry);
+      }
+
+      containerEntry.setValueStorages(list);
+
+      // Indexer
+      params = new ArrayList<SimpleParameterEntry>();
+      params.addAll(copyList(baseWorkspaceEntry.getQueryHandler().getParameters()));
+      QueryHandlerEntry qEntry = new QueryHandlerEntry(baseWorkspaceEntry.getQueryHandler().getType(), params);
+
+      // Cache
+      params = new ArrayList<SimpleParameterEntry>();
+      params.addAll(copyList(baseWorkspaceEntry.getCache().getParameters()));
+      CacheEntry cacheEntry = new CacheEntry(params);
+      cacheEntry.setType(baseWorkspaceEntry.getCache().getType());
+
+      WorkspaceEntry workspaceEntry = new WorkspaceEntry();
+      workspaceEntry.setContainer(containerEntry);
+      workspaceEntry.setCache(cacheEntry);
+      workspaceEntry.setQueryHandler(qEntry);
+      workspaceEntry.setName(baseWorkspaceEntry.getName());
+      workspaceEntry.setUniqueName(baseWorkspaceEntry.getUniqueName());
+
+      return workspaceEntry;
+
+   }
+
+   /**
+    * Create copy of repository entry. 
+    */
+   public RepositoryEntry copyRepositoryEntry(RepositoryEntry baseRepositoryEntry) throws Exception
+   {
+      ArrayList<WorkspaceEntry> wsEntries = new ArrayList<WorkspaceEntry>();
+
+      for (WorkspaceEntry wsEntry : baseRepositoryEntry.getWorkspaceEntries())
+      {
+         WorkspaceEntry newWSEntry = copyWorkspaceEntry(wsEntry);
+
+         wsEntries.add(newWSEntry);
+      }
+
+      RepositoryEntry newRepositoryEntry = new RepositoryEntry();
+
+      newRepositoryEntry.setSystemWorkspaceName(baseRepositoryEntry.getSystemWorkspaceName());
+      newRepositoryEntry.setAccessControl(baseRepositoryEntry.getAccessControl());
+      newRepositoryEntry.setAuthenticationPolicy(baseRepositoryEntry.getAuthenticationPolicy());
+      newRepositoryEntry.setDefaultWorkspaceName(baseRepositoryEntry.getDefaultWorkspaceName());
+      newRepositoryEntry.setName(baseRepositoryEntry.getName());
+      newRepositoryEntry.setSecurityDomain(baseRepositoryEntry.getSecurityDomain());
+      newRepositoryEntry.setSessionTimeOut(baseRepositoryEntry.getSessionTimeOut());
+
+      newRepositoryEntry.setWorkspaceEntries(wsEntries);
+      return newRepositoryEntry;
+
+   }
+
+   /**
+    * Create copy of list with SimpleParameterEntry-s
+    */
+   private List<SimpleParameterEntry> copyList(List<SimpleParameterEntry> baseArrayList)
+   {
+      ArrayList<SimpleParameterEntry> arrayList = new ArrayList<SimpleParameterEntry>();
+
+      for (SimpleParameterEntry baseParameter : baseArrayList)
+      {
+         arrayList.add(new SimpleParameterEntry(baseParameter.getName(), baseParameter.getValue()));
+      }
+
+      return arrayList;
+   }
+
+   /**
+    * Create workspace entry. 
+    */
+   public WorkspaceEntry createWorkspaceEntry(boolean isMultiDb, String dsName) throws Exception
+   {
+      List<String> ids = new ArrayList<String>();
+      ids.add("id");
+
+      return createWorkspaceEntry(isMultiDb, dsName, ids);
+   }
+
+   /**
+    * Create workspace entry. 
+    */
+   public WorkspaceEntry createWorkspaceEntry(boolean isMultiDb, String dsName, List<String> valueStorageIds)
+      throws Exception
+   {
+      if (dsName == null)
+      {
+         dsName = createDatasource();
+      }
+
+      String id = IdGenerator.generate();
+      String wsName = "ws-" + id;
+
+      // container entry
+      List params = new ArrayList();
+      params.add(new SimpleParameterEntry("source-name", dsName));
+      params.add(new SimpleParameterEntry("multi-db", isMultiDb ? "true" : "false"));
+      params.add(new SimpleParameterEntry("max-buffer-size", "204800"));
+      params.add(new SimpleParameterEntry("dialect", "auto"));
+      params.add(new SimpleParameterEntry("swap-directory", "target/temp/swap/" + wsName));
+
+      ContainerEntry containerEntry =
+         new ContainerEntry("org.exoplatform.services.jcr.impl.storage.jdbc.JDBCWorkspaceDataContainer",
+            (ArrayList)params);
+      containerEntry.setParameters(params);
+
+      // value storage
+      ArrayList list = new ArrayList();
+      if (valueStorageIds != null)
+      {
+         for (String vsId : valueStorageIds)
+         {
+            ArrayList<ValueStorageFilterEntry> vsparams = new ArrayList<ValueStorageFilterEntry>();
+            ValueStorageFilterEntry filterEntry = new ValueStorageFilterEntry();
+            filterEntry.setPropertyType("Binary");
+            vsparams.add(filterEntry);
+
+            ValueStorageEntry valueStorageEntry =
+               new ValueStorageEntry("org.exoplatform.services.jcr.impl.storage.value.fs.SimpleFileValueStorage",
+                  vsparams);
+            ArrayList<SimpleParameterEntry> spe = new ArrayList<SimpleParameterEntry>();
+            spe.add(new SimpleParameterEntry("path", "target/temp/values/" + wsName + "-" + vsId));
+            valueStorageEntry.setId(vsId);
+            valueStorageEntry.setParameters(spe);
+            valueStorageEntry.setFilters(vsparams);
+
+            // containerEntry.setValueStorages();
+            containerEntry.setParameters(params);
+            list.add(valueStorageEntry);
+         }
+      }
+
+      containerEntry.setValueStorages(list);
+
+      // Indexer
+      params = new ArrayList();
+      params.add(new SimpleParameterEntry("index-dir", "target/temp/index/" + wsName));
+      QueryHandlerEntry qEntry =
+         new QueryHandlerEntry("org.exoplatform.services.jcr.impl.core.query.lucene.SearchIndex", params);
+
+      // Cache
+      ArrayList cacheParams = new ArrayList();
+      cacheParams.add(new SimpleParameterEntry("maxSize", "2000"));
+      cacheParams.add(new SimpleParameterEntry("liveTime", "20m"));
+      CacheEntry cacheEntry = new CacheEntry(cacheParams);
+      cacheEntry.setType("org.exoplatform.services.jcr.impl.dataflow.persistent.LinkedWorkspaceStorageCacheImpl");
+
+      WorkspaceEntry workspaceEntry = new WorkspaceEntry();
+      workspaceEntry.setContainer(containerEntry);
+      workspaceEntry.setCache(cacheEntry);
+      workspaceEntry.setQueryHandler(qEntry);
+      workspaceEntry.setName(wsName);
+      workspaceEntry.setUniqueName(wsName);
+
+      return workspaceEntry;
+   }
+
+   public List<String> getValueStorageIds(ArrayList<ValueStorageEntry> entries)
+   {
+      List<String> ids = new ArrayList<String>();
+      if (entries != null)
+      {
+         for (ValueStorageEntry entry : entries)
+         {
+            ids.add(entry.getId());
+         }
+      }
+
+      return ids;
+   }
+
+   public static TesterConfigurationHelper getInstance()
+   {
+      if (instance == null)
+      {
+         instance = new TesterConfigurationHelper();
+      }
+
+      return instance;
+   }
+
+}

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<section id="JCR.QueryHandlerConfiguration" role="NotInToc">
  <title>QueryHandler configuration</title>

  <para>Before going deeper into the <emphasis>QueryHandler</emphasis> configuration, you need to learn about the concept of Indexing
  in clustered environment.</para>
 
  <para xml:id="JCR.QueryHandlerConfiguration.Indexing_in_clustered_environment">
    <citetitle><emphasis role="bold">Indexing in clustered environment</emphasis></citetitle>
  </para>

    <para>JCR offers multiple indexing strategies. They include both strategies for
    standalone and clustered environments using the advantages of running in a
    single JVM or doing the best to use all resources available in cluster.
    JCR uses Lucene library as underlying search and indexing engine, but it
    has several limitations that greatly reduce possibilities and limits the
    usage of cluster advantages. That is why JCR offers three strategies
    that are suitable for it's own usecases. They are standalone, clustered
    with shared index and clustered with local indexes. Each one has its pros
    and cons.</para>

    <para>Standalone strategy provides a stack of indexes to achieve greater
    performance within single JVM.</para>

    <mediaobject>
      <imageobject>
        <imagedata align="center"
                   fileref="images/diagram-standalone-index.png" />
      </imageobject>
    </mediaobject>

    <para>It combines in-memory buffer index directory with delayed
    file-system flushing. This index is called "Volatile" and it is invoked in
    searches also. Within some conditions volatile index is flushed to the
    persistent storage (file system) as new index directory. This allows to
    achieve great results for write operations.</para>

    <para>Clustered implementation with local indexes is built upon same
    strategy with volatile in-memory index buffer along with delayed flushing
    on persistent storage.</para>

    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="images/diagram-local-index.png" />
      </imageobject>
    </mediaobject>

    <para>As this implementation designed for clustered environment, it has
    additional mechanisms for data delivery within cluster. Actual text
    extraction jobs are done on the same node that does content operations (for example:
    write operation). Prepared "documents" (Lucene term that means block of
    data ready for indexing) are replicated withing cluster nodes and
    processed by local indexes. So each cluster instance has the same index
    content. When new node joins the cluster, it has no initial index, so it
    must be created. There are some supported ways of doing this operation.
    The simplest is to simply copy the index manually but this is not intended
    for use. If no initial index is found, JCR will use the automated scenarios. They are
    controlled via configuration (see the <link linkend="JCR.QueryHandlerConfiguration.Configuration.Query-handlerConfigurationOverview">index-recovery-mode parameter</link> )
    offering full re-indexing from database or copying from another cluster
    node.</para>

    <para>For some reasons having a multiple index copies on each instance can
    be costly. So shared index can be used instead (see diagram below).</para>

    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="images/diagram-shared-index.png" />
      </imageobject>
    </mediaobject>

    <para>This indexing strategy combines advantages of in-memory index along
    with shared persistent index offering "near" real time search
    capabilities. This means that newly added content is accessible via search
    practically immediately. This strategy allows nodes to index data in their
    own volatile (in-memory) indexes, but persistent indexes are managed by
    single "coordinator" node only. Each cluster instance has a read access
    for shared index to perform queries combining search results found in own
    in-memory index also. Take in account that shared folder must be
    configured in your system environment (for example: mounted NFS folder). However, this
    strategy in some extremely rare cases may have a bit different volatile
    indexes within cluster instances for a while. In a few seconds they will
    be up to date.</para>

    <para>See more about <link linkend="JCR.SearchConfiguration">Search
    Configuration</link>.</para>
  
    <!-- 2.2.3.1 Query-handler parameters -->
    <section id="JCR.QueryHandlerConfiguration.Configuration.Query-handlerConfigurationOverview">
      <title>Query-handler parameters</title>

      <para>See the following sample configuration :</para>

      <programlisting language="xml">&lt;workspace name="ws"&gt;
   &lt;query-handler class="org.exoplatform.services.jcr.impl.core.query.lucene.SearchIndex"&gt;
      &lt;properties&gt;
         &lt;property name="index-dir" value="shareddir/index/db1/ws" /&gt;
         &lt;property name="changesfilter-class"
            value="org.exoplatform.services.jcr.impl.core.query.jbosscache.JBossCacheIndexChangesFilter" /&gt;
         &lt;property name="jbosscache-configuration" value="jbosscache-indexer.xml" /&gt;
         &lt;property name="jgroups-configuration" value="udp-mux.xml" /&gt;
         &lt;property name="jgroups-multiplexer-stack" value="true" /&gt;
         &lt;property name="jbosscache-cluster-name" value="JCR-cluster-indexer-ws" /&gt;
         &lt;property name="max-volatile-time" value="60" /&gt;
         &lt;property name="rdbms-reindexing" value="true" /&gt;
         &lt;property name="reindexing-page-size" value="1000" /&gt;
         &lt;property name="index-recovery-mode" value="from-coordinator" /&gt;
         &lt;property name="index-recovery-filter" value="org.exoplatform.services.jcr.impl.core.query.lucene.DocNumberRecoveryFilter" /&gt;
         &lt;property name="indexing-thread-pool-size" value="16" /&gt;
      &lt;/properties&gt;
   &lt;/query-handler&gt;
&lt;/workspace&gt;
</programlisting>

      <table>
        <title>Config properties description</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Property name</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><parameter>index-dir</parameter></entry>

              <entry>Path to index.</entry>
            </row>

            <row>
              <entry><parameter>changesfilter-class</parameter></entry>

              <entry>Template of JBoss-cache configuration for all
              query-handlers in repository.</entry>
            </row>

            <row>
              <entry><parameter>jbosscache-configuration</parameter></entry>

              <entry>Template of JBoss-cache configuration for all
              query-handlers in repository.</entry>
            </row>

            <row>
              <entry><parameter>jgroups-configuration</parameter></entry>

              <entry>Template configuration for all
              components (search, cache, locks) [Add link to document
              describing template configurations].</entry>
            </row>

            <row>
              <entry><parameter>jgroups-multiplexer-stack</parameter></entry>

              <entry>If set to "true", it will indicate that the file corresponding to the parameter jgroups-configuration is a actually a file defining a set of jgroups multiplexer stacks.
                  In the XML tag jgroupsConfig within the jboss cache configuration, you will then be able to set the name of the multiplexer stack to use thanks to the attribute multiplexerStack.
                  Please note that the jgroups multiplexer has been deprecated by the jgroups Team and has been replaced by the shared transport so it is highly recommended to not use it anymore..</entry>
            </row>

            <row>
              <entry><parameter>jbosscache-cluster-name</parameter></entry>

              <entry>Cluster name which must be unique.</entry>
            </row>

            <row>
              <entry><parameter>max-volatile-time</parameter></entry>

              <entry>Max time to live for Volatile Index.</entry>
            </row>

            <row>
              <entry><parameter>rdbms-reindexing</parameter></entry>

              <entry>Indicate that it is needed to use RDBMS re-indexing mechanism if
              possible, the default value is "true".</entry>
            </row>

            <row>
              <entry><parameter>reindexing-page-size</parameter></entry>

              <entry>The maximum amount of nodes which can be retrieved from
              storage for re-indexing purpose, the default value is
              "100".</entry>
            </row>

            <row>
              <entry><parameter>index-recovery-mode</parameter></entry>

              <entry>If the parameter has been set to <command>from-indexing</command>, a full indexing will be
              automatically launched. If the parameter has been set to
              <command>from-coordinator</command> (default behavior), the
              index will be retrieved from coordinator.</entry>
            </row>

            <row>
              <entry><parameter>index-recovery-filter</parameter></entry>

              <entry>Define implementation class or classes of
              RecoveryFilters, the mechanism of index synchronization for
              Local Index strategy.</entry>
            </row>

            <row>
              <entry><parameter>async-reindexing</parameter></entry>

              <entry>Control the process of re-indexing on JCR's startup. If
              flag set, indexing will be launched asynchronously, without
              blocking the JCR. The default value is "false".</entry>
            </row>

            <row>
              <entry><parameter>indexing-thread-pool-size</parameter></entry>

              <entry>Define the total amount of indexing threads.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <note>
		<itemizedlist>
			<listitem>
				<para>If you use postgreSQL and the parameter rdbms-reindexing is set
				to "true", the performances of the queries used while indexing can be
				improved by setting the parameter "enable_seqscan" to "off" or
				"default_statistics_target" to at least "50" in the configuration of
				your database. Then you need to restart DB server and make analyze of
				the JCR_SVALUE (or JCR_MVALUE) table.</para>
			</listitem>
			<listitem>
				<para>If you use DB2 and the parameter rdbms-reindexing is set to
				"true", the performance of the queiries used while indexing can be
				improved by making statisticks on tables by running "RUNSTATS ON TABLE
				&lt;scheme&gt;.&lt;table&gt; WITH DISTRIBUTION AND INDEXES ALL" for
				JCR_SITEM (or JCR_MITEM) and JCR_SVALUE (or JCR_MVALUE) tables.</para>
			</listitem>
		</itemizedlist>
      </note>
    </section>
    <!-- 2.2.3.2 Cluster-ready indexing strategies -->
    <section id="JCR.QueryHandlerConfiguration.Configuration.Cluster-readyIndexingStrategies">
      <title>Cluster-ready indexing strategies</title>

      <para>For both cluster-ready implementations JBoss Cache, JGroups and
      Changes Filter values must be defined. Shared index requires some kind
      of remote or shared file system to be attached in a system (for example: NFS,
      SMB and so on).
      </para>
      <para>Indexing directory ("indexDir" value) must point to it.
      Setting "changesfilter-class" to
      "org.exoplatform.services.jcr.impl.core.query.jbosscache.JBossCacheIndexChangesFilter"
      will enable shared index implementation.
      </para>

<programlisting language="xml">&lt;workspace name="ws"&gt;
   &lt;query-handler class="org.exoplatform.services.jcr.impl.core.query.lucene.SearchIndex"&gt;
      &lt;properties&gt;
         &lt;property name="index-dir" value="/mnt/nfs_drive/index/db1/ws" /&gt;
         &lt;property name="changesfilter-class"
            value="org.exoplatform.services.jcr.impl.core.query.jbosscache.JBossCacheIndexChangesFilter" /&gt;
         &lt;property name="jbosscache-configuration" value="jbosscache-indexer.xml" /&gt;
         &lt;property name="jgroups-configuration" value="udp-mux.xml" /&gt;
         &lt;property name="jgroups-multiplexer-stack" value="false" /&gt;
         &lt;property name="jbosscache-cluster-name" value="JCR-cluster-indexer" /&gt;
         &lt;property name="max-volatile-time" value="60" /&gt;
         &lt;property name="rdbms-reindexing" value="true" /&gt;
         &lt;property name="reindexing-page-size" value="1000" /&gt;
         &lt;property name="index-recovery-mode" value="from-coordinator" /&gt;
         &lt;property name="jbosscache-shareable" value="true" /&gt;
      &lt;/properties&gt;
   &lt;/query-handler&gt;
&lt;/workspace&gt;</programlisting>

      <para>To use cluster-ready strategy based on local indexes,
      the following configuration must be applied when each node has its own copy of index on local file system.
      Indexing directory must point to any folder on local file system and "changesfilter-class" must be set to
      "org.exoplatform.services.jcr.impl.core.query.jbosscache.LocalIndexChangesFilter".</para>

<programlisting language="xml">&lt;workspace name="ws"&gt;
   &lt;query-handler class="org.exoplatform.services.jcr.impl.core.query.lucene.SearchIndex"&gt;
      &lt;properties&gt;
         &lt;property name="index-dir" value="/mnt/nfs_drive/index/db1/ws" /&gt;
         &lt;property name="changesfilter-class"
            value="org.exoplatform.services.jcr.impl.core.query.jbosscache.LocalIndexChangesFilter" /&gt;
         &lt;property name="jbosscache-configuration" value="jbosscache-indexer.xml" /&gt;
         &lt;property name="jgroups-configuration" value="udp-mux.xml" /&gt;
         &lt;property name="jgroups-multiplexer-stack" value="false" /&gt;
         &lt;property name="jbosscache-cluster-name" value="JCR-cluster-indexer" /&gt;
         &lt;property name="max-volatile-time" value="60" /&gt;
         &lt;property name="rdbms-reindexing" value="true" /&gt;
         &lt;property name="reindexing-page-size" value="1000" /&gt;
         &lt;property name="index-recovery-mode" value="from-coordinator" /&gt;
         &lt;property name="jbosscache-shareable" value="true" /&gt;
      &lt;/properties&gt;
   &lt;/query-handler&gt;
&lt;/workspace&gt;</programlisting>

      <para id="JCR.QueryHandlerConfiguration.Configuration.Cluster-readyIndexingStrategies.LocalIndexRecoveryFilters">
        <citetitle><emphasis role="bold">Local Index Recovery Filters</emphasis></citetitle>
      </para>
        <para>Common usecase for all cluster-ready applications is a hot
        joining and leaving of processing units. All nodes that are joining cluster
        for the first time or after some downtime must
        be in a synchronized state.</para>
        <para>
        When having a deal with shared value
        storages, databases and indexes, cluster nodes are synchronized
        anytime. However it is an issue when local index strategy is used. If the new node
        joins cluster having no index, it will be retrieved or recreated. Node can
        be restarted also and thus index is not empty. Usually existing index is
        thought to be actual, but can be outdated.
        </para>
        <para>JCR offers a mechanism called RecoveryFilters that will automatically retrieve index for the
        joining node on startup. This feature is a set of filters that can be
        defined via QueryHandler configuration:</para>

        <programlisting language="xml">&lt;property name="index-recovery-filter" value="org.exoplatform.services.jcr.impl.core.query.lucene.DocNumberRecoveryFilter" /&gt;</programlisting>

        <para>Filter number is not limited so they can be combined:</para>

        <programlisting language="xml">&lt;property name="index-recovery-filter" value="org.exoplatform.services.jcr.impl.core.query.lucene.DocNumberRecoveryFilter" /&gt;
&lt;property name="index-recovery-filter" value="org.exoplatform.services.jcr.impl.core.query.lucene.SystemPropertyRecoveryFilter" /&gt;
</programlisting>

        <para>If any one fires, the index is re-synchronized. Please take in
        account that DocNumberRecoveryFilter is used in cases no filter is
        configured. So, if resynchronization should be blocked or strictly
        required on start, then ConfigurationPropertyRecoveryFilter can be
        used.</para>

        <para>This feature uses the standard index recovery mode defined by
        previously described parameter (can be "from-indexing" or
        "from-coordinator" (default value)).</para>

<programlisting language="xml">&lt;property name="index-recovery-mode" value="from-coordinator" /&gt;</programlisting>

        <para>There are couple implementations of filters:</para>

        <itemizedlist>
          <listitem>
            <para><parameter>org.exoplatform.services.jcr.impl.core.query.lucene.DummyRecoveryFilter</parameter>: Always return true, for cases when index must be force
            resynchronized (recovered) each time;</para>
          </listitem>

          <listitem>
            <para><parameter>org.exoplatform.services.jcr.impl.core.query.lucene.SystemPropertyRecoveryFilter</parameter>: Return value of system property
            "org.exoplatform.jcr.recoveryfilter.forcereindexing". So index
            recovery can be controlled from the top without changing
            documentation using system properties;</para>
          </listitem>

          <listitem>
            <para><parameter>org.exoplatform.services.jcr.impl.core.query.lucene.ConfigurationPropertyRecoveryFilter</parameter>: Return value of QueryHandler configuration property
            "index-recovery-filter-forcereindexing" so the index recovery can be
            controlled from configuration separately for each workspace.
            For example:</para>

<programlisting language="xml">&lt;property name="index-recovery-filter" value="org.exoplatform.services.jcr.impl.core.query.lucene.ConfigurationPropertyRecoveryFilter" /&gt;
&lt;property name="index-recovery-filter-forcereindexing" value="true" /&gt;</programlisting>
          </listitem>

          <listitem>
            <para><parameter>org.exoplatform.services.jcr.impl.core.query.lucene.DocNumberRecoveryFilter</parameter>: Check number of documents in index on coordinator side and
            self-side and return true if differs. Advantage of this filter
            comparing to other is it will skip reindexing for workspaces where
            index was not modified. For example, there are 10 repositories with 3
            workspaces in each one. Only one is really heavily used in cluster: frontend/production. So using this filter will only re-index
            those workspaces that are really changed, without affecting other
            indexes thus greatly reduce the startup time.</para>
          </listitem>
        </itemizedlist>      
    </section>  

  <!-- 2.2.3.3. Asynchronous reindexing -->
  <section id="JCR.QueryHandlerConfiguration.Asynchronous_reindexing">
    <title>Asynchronous re-indexing</title>

    <para>Managing a big set of data using JCR in production environment
    sometimes requires special operations with Indexes stored on File System.
    One of those maintenance operations is a recreation of it or
    "re-indexing". There are various usecases when re-indexing is important to do. They
    include hardware faults, hard restarts, data-corruption, migrations and
    JCR updates that brings new features related to index. Usually, index
    re-creation requested on server's startup or in runtime.</para>
    <note>      
      <para id="JCR.QueryHandlerConfiguration.Asynchronous_reindexing.Notices">
      First of all, you can not launch Hot re-indexing via JMX if index is
      already in offline mode. It means that index is currently invoked in
      some operations, like re-indexing at startup, copying in cluster to
      another node or whatever. Another important notice is Hot Asynchronous
      Reindexing via JMX and "on startup" re-indexing are completely different
      features. So you can not get the state of startup re-indexing using the command
      getHotReindexingState in JMX interface, but there are some common JMX
      operations:
      </para>
      <itemizedlist>
        <listitem>
          <para>getIOMode: return the current index IO mode (READ_ONLY /
          READ_WRITE), belongs to clustered configuration states.</para>
        </listitem>
        <listitem>
          <para>getState: return the current state (ONLINE / OFFLINE).</para>
        </listitem>
      </itemizedlist>
    </note>
    <!-- On startup indexing -->
    <para id="JCR.QueryHandlerConfiguration.Asynchronous_reindexing.OnStartupIndexing">
      <citetitle><emphasis role="bold">On startup indexing</emphasis></citetitle>
    </para>
      <para>Common usecase for updating and re-creating the index is to stop
      the server and manually remove indexes for workspaces requiring it. When
      server will be started, missing indexes are automatically recovered by
      re-indexing.</para>
      <para>JCR Supports direct RDBMS re-indexing, that is usually
      faster than ordinary and can be configured via QueryHandler parameter
      "rdbms-reindexing" set to "true" (for more information please refer to
      the <link linkend="JCR.QueryHandlerConfiguration">Query-handler configuration overview</link>).</para>
      <para>One new feature to introduce is
      the asynchronous indexing on startup. Usually the startup is blocked until
      the process is finished. Block can take any period of time, depending on
      amount of data persisted in repositories. However, this can be resolved by
      using an asynchronous approaches of startup indexation. In brief,
      it performs all operations with index in background, without blocking
      the repository. This is controlled by the value of "async-reindexing"
      parameter in QueryHandler configuration. With asynchronous indexation
      active, JCR starts with no active indexes present. Queries on JCR still
      can be executed without exceptions but no results will be returned
      until index creation completed. Checking index state is possible via
      QueryManagerImpl:</para>

      <para><programlisting lang="java">boolean online = ((QueryManagerImpl)Workspace.getQueryManager()).getQueryHandeler().isOnline();</programlisting></para>

      <para>"OFFLINE" state means that index is currently re-creating. When
      the state changed, the corresponding log event is printed. From the start of
      background task, index is switched to "OFFLINE" with the following log event:</para>

      <programlisting>[INFO] Setting index OFFLINE (repository/production[system]).</programlisting>

      <para>When the process has been finished, two events are logged:</para>

      <programlisting>[INFO] Created initial index for 143018 nodes (repository/production[system]).
[INFO] Setting index ONLINE (repository/production[system]).</programlisting>

      <para>Those two log lines indicates the end of process for workspace
      given in brackets. Calling isOnline() as mentioned above, will also
      return true.</para>    
      <!-- Hot Asynchronous Workspace Reindexing via JMX -->
    <para id="JCR.QueryHandlerConfiguration.Asynchronous_reindexing.HotAsynchronousWorkspaceReindexingViaJMX">
      <citetitle><emphasis role="bold">Hot asynchronous workspace reindexing via JMX</emphasis></citetitle>
    </para>
      <para>Some hard system faults, error during upgrades, migration issues
      and some other factors may corrupt the index. Most likely end customers
      would like the production systems to fix index issues in run-time
      without delays and restarts. Current versions of JCR supports "Hot
      Asynchronous Workspace Reindexing" feature. It allows end-user (Service
      Administrator) to launch the process in background without stopping or
      blocking the whole application by using any JMX-compatible console (see
      the "JConsole in action" screenshot below).<mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/jmx-jconsole.png" />
          </imageobject>
        </mediaobject>The server can continue working as expected while index is
      re-created. This depends on the flag "allow queries", passed via JMX
      interface to re-index operation invocation. If the flag set, then the
      application continues working. However, there is one critical limitation that the
      end-users must be aware. If the index is frozen while background task is
      running, it means queries are performed on index present on the
      moment of task startup and data written into repository after startup
      will not be available through the search until the process finished. Data added
      during re-indexation is also indexed, but will be available only when
      task is done. Briefly, JCR makes the snapshot of indexes on asynch task
      startup and uses it for searches. When operation finished, stale indexes
      are replaced by newly created including newly added data. If the flag "allow
      queries" is set to "false", then all queries will throw an exception while
      the task is running. Current state can be acquired using the following JMX
      operation:</para>

      <itemizedlist>
        <listitem>
          <para>getHotReindexingState(): return information about latest
          invocation: start time, if in progress or finish time if
          done.</para>
        </listitem>
      </itemizedlist>    
  </section>
  <!-- 2.2.3.4. Lucene tuning -->
  <section id="JCR.QueryHandlerConfiguration.Advanced_tuning.LuceneTuning">
      <title>Lucene tuning</title>
      <para>As mentioned above, JCR Indexing is based on Lucene indexing
      library as underlying search engine. It uses Directories to store index
      and manages access to index by Lock Factories.</para>
      <para>
      By default, JCR
      implementation uses optimal combination of Directory implementation and
      Lock Factory implementation. When running on OS different from Windows,
      NIOFSDirectory implementation is used and SimpleFSDirectory is used for Windows
      stations.
      </para>
      <para>
      NativeFSLockFactory is an optimal solution for wide variety of
      cases including clustered environment with NFS shared resources. However,
      those defaults can be overridden with the help of system properties. There are two properties that are responsible for
      changing default behavior:</para>
      <itemizedlist>
        <listitem>"org.exoplatform.jcr.lucene.store.FSDirectoryLockFactoryClass": define implementation of abstract
      Lucene LockFactory class.</listitem>
        <listitem>"org.exoplatform.jcr.lucene.FSDirectory.class": set implementation class
      for FSDirectory instances.</listitem>
      </itemizedlist>

      <note>
      <para>For more information please refer to Lucene
      documentation but <emphasis role="bold">make sure that you know what you are changing</emphasis>. JCR allows
      end users to change implementation classes of Lucene internals, but
      does not guarantee its stability and functionality.</para>
      </note>
  </section>  
</section>

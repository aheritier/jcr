<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<!--3.2.2.3. How to implement workspace data container-->
<section id="JCR.HowToImplementWorkspaceDataContainer">
  <title>How to implement workspace data container</title>

  <para xml:id="JCR.JDBCDataContainerConfig.Single-databaseConfiguration.DynamicWorkspaceCreation">
    <citetitle>
      <emphasis role="bold">Create a dynamic workspace</emphasis>
    </citetitle>
  </para>
  <para>Workspaces can be added dynamically during runtime.</para>

  <para>This can be performed in two steps:
    <itemizedlist>
      <listitem>
        <para>Firstly,
          <classname>ManageableRepository.configWorkspace(WorkspaceEntry
            wsConfig)
          </classname>
          - register a new configuration in
          RepositoryContainer and create a WorkspaceContainer.
        </para>
      </listitem>

      <listitem>
        <para>Secondly, the main step,
          <classname>ManageableRepository.createWorkspace(String
            workspaceName)
          </classname>
          - creation of a new workspace.
        </para>
      </listitem>
    </itemizedlist>
  </para>

  <para xml:id="JCR.ImplementWorkspaceDataContainer">
    <citetitle>
      <emphasis role="bold">Implement a workspace data container</emphasis>
    </citetitle>
  </para>
  <para>To implement Workspace data container, you need to do the following:
    </para>

    <orderedlist>
      <listitem>
        <para>Read a bit about the <link
        linkend="JCRref.Introduction.JCRArchitecture">contract</link>.</para>
      </listitem>

      <listitem>
        <para>Start a new implementation project <filename>pom.xml</filename> with
        <emphasis>org.exoplatform.jcr</emphasis> parent. It is not required, but will ease the development.</para>
      </listitem>

      <listitem>
        <para>Update sources of JCR Core and read JavaDoc on <parameter>org.exoplatform.services.jcr.storage.WorkspaceDataContainer</parameter>
        and <parameter>org.exoplatform.services.jcr.storage.WorkspaceStorageConnection</parameter>
        interfaces. They are the main part for the implementation.</para>
      </listitem>

      <listitem>
        <para>Look at <parameter>org.exoplatform.services.jcr.impl.dataflow.persistent.WorkspacePersistentDataManager</parameter>
        sourcecode, check how data manager uses container and its connections
        (see in the <parameter>save()</parameter> method)</para>
      </listitem>

      <listitem>
        <para>Create <parameter>WorkspaceStorageConnection</parameter> dummy implementation
        class. It is a freeform class, but to be close to the eXo JCR, check how
        to implement JDBC or SimpleDB containers ( <parameter>org.exoplatform.services.jcr.impl.storage.jdbc.JDBCStorageConnection</parameter>
        and <parameter>org.exoplatform.services.jcr.aws.storage.sdb.SDBWorkspaceStorageConnection</parameter>).
        Take into account usage of <parameter>ValueStoragePluginProvider</parameter> in both
        implementations. Value storage is a useful option for production
        versions, but leave it to the end of the implementation work.</para>
      </listitem>

      <listitem>
        <para>Create the connection implementation unit tests to play TTD.
        This step is optional but brings many benefits for the process.</para>
      </listitem>

      <listitem>
        <para>Implement CRUD starting from, for example, the read to write. Test the
        methods by using the external implementation ways of data read/write
        in your backend.</para>
      </listitem>

      <listitem>
        <para>When all methods of the connection are done, start <emphasis
        role="bold">WorkspaceDataContainer</emphasis>. Container class is very
        simple, it is like a factory for the connections only.</para>
      </listitem>

      <listitem>
        <para>Care about the <parameter>reuseConnection(WorkspaceStorageConnection)</parameter>
        logic container method. For some backends, it can be same as <parameter>openConnection()</parameter>;
        but for some others, it is important to reuse physical backend
        connection, for example, to be in the same transaction - see JDBC
        container.</para>
      </listitem>

      <listitem>
        <para>It is almost ready to use in data manager. Start another test.</para>
      </listitem>
    </orderedlist>

  <para>When the container is ready to run as JCR persistence storage (for example, for this level testing), it should
    be configured in Repository configuration.
  </para>

    <para>Assuming that the new implementation class name is <parameter>org.project.jcr.impl.storage.MyWorkspaceDataContainer</parameter>.</para>

    <programlisting language="xml">  &lt;repository-service default-repository="repository"&gt;
  &lt;repositories&gt;
    &lt;repository name="repository" system-workspace="production" default-workspace="production"&gt;
      .............
      &lt;workspaces&gt;
        &lt;workspace name="production"&gt;
          &lt;container class="org.project.jcr.impl.storage.MyWorkspaceDataContainer"&gt;
            &lt;properties&gt;
              &lt;property name="propertyName1" value="propertyValue1" /&gt;
              &lt;property name="propertyName2" value="propertyValue2" /&gt;
              .......
              &lt;property name="propertyNameN" value="propertyValueN" /&gt;
            &lt;/properties&gt;
            &lt;value-storages&gt;
              .......
            &lt;/value-storages&gt;
          &lt;/container&gt;</programlisting>

    <para>Container can be configured by using set properties.</para>

  <para xml:id="Valuestorageusagenotes">
    <citetitle>
      <emphasis role="bold">Value storage usage</emphasis>
    </citetitle>
  </para>

    <para>Value storages are pluggable to the container but if they are used,
    the container implementation should respect set of interfaces and external
    storage usage principles.</para>

    <para>If the container has <emphasis
    role="bold">ValueStoragePluginProvider</emphasis> (for example, via constructor),
    it is just a method to manipulate external Values data.</para>

    <programlisting language="java">// get channel for ValueData write (add or update)
ValueIOChannel channel = valueStorageProvider.getApplicableChannel(data,  i);
if (channel == null) {
  // write
  channel.write(data.getIdentifier(),  vd);
  // obtain storage id,  id can be used for linkage of external ValueData and PropertyData in main backend
  String storageId = channel.getStorageId();
}

....

// delete all Property Values in external storage
ValueIOChannel channel = valueStorageProvider.getChannel(storageId);
channel.delete(propertyData.getIdentifier());

....

// read ValueData from external storage
ValueIOChannel channel = valueStorageProvider.getChannel(storageId);
ValueData vdata = channel.read(propertyData.getIdentifier(),  orderNumber,  maxBufferSize);

</programlisting>

    <note>
          <para>After a sequence of write and/or delete operations on the storage
      channel, the channel should be committed (or rolled back on an error).
      See <parameter>ValueIOChannel.commit()</parameter> and
      <parameter>ValueIOChannel.rollback()</parameter> and how those
      methods are used in the JDBC container.</para>
    </note>
</section>
